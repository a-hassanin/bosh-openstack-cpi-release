// Code generated by counterfeiter. DO NOT EDIT.
package openstackfakes

import (
	"sync"

	"github.com/cloudfoundry/bosh-openstack-cpi-release/src/openstack_cpi_golang/cpi/config"
	"github.com/cloudfoundry/bosh-openstack-cpi-release/src/openstack_cpi_golang/cpi/openstack"
	"github.com/gophercloud/gophercloud"
)

type FakeOpenstackService struct {
	BlockStorageV3Stub        func(config.OpenstackConfig) (*gophercloud.ServiceClient, error)
	blockStorageV3Mutex       sync.RWMutex
	blockStorageV3ArgsForCall []struct {
		arg1 config.OpenstackConfig
	}
	blockStorageV3Returns struct {
		result1 *gophercloud.ServiceClient
		result2 error
	}
	blockStorageV3ReturnsOnCall map[int]struct {
		result1 *gophercloud.ServiceClient
		result2 error
	}
	ComputeServiceV2Stub        func(config.OpenstackConfig) (*gophercloud.ServiceClient, error)
	computeServiceV2Mutex       sync.RWMutex
	computeServiceV2ArgsForCall []struct {
		arg1 config.OpenstackConfig
	}
	computeServiceV2Returns struct {
		result1 *gophercloud.ServiceClient
		result2 error
	}
	computeServiceV2ReturnsOnCall map[int]struct {
		result1 *gophercloud.ServiceClient
		result2 error
	}
	ImageServiceV2Stub        func(config.OpenstackConfig) (*gophercloud.ServiceClient, error)
	imageServiceV2Mutex       sync.RWMutex
	imageServiceV2ArgsForCall []struct {
		arg1 config.OpenstackConfig
	}
	imageServiceV2Returns struct {
		result1 *gophercloud.ServiceClient
		result2 error
	}
	imageServiceV2ReturnsOnCall map[int]struct {
		result1 *gophercloud.ServiceClient
		result2 error
	}
	LoadbalancerV2Stub        func(config.OpenstackConfig) (*gophercloud.ServiceClient, error)
	loadbalancerV2Mutex       sync.RWMutex
	loadbalancerV2ArgsForCall []struct {
		arg1 config.OpenstackConfig
	}
	loadbalancerV2Returns struct {
		result1 *gophercloud.ServiceClient
		result2 error
	}
	loadbalancerV2ReturnsOnCall map[int]struct {
		result1 *gophercloud.ServiceClient
		result2 error
	}
	NetworkServiceV2Stub        func(config.OpenstackConfig) (*gophercloud.ServiceClient, error)
	networkServiceV2Mutex       sync.RWMutex
	networkServiceV2ArgsForCall []struct {
		arg1 config.OpenstackConfig
	}
	networkServiceV2Returns struct {
		result1 *gophercloud.ServiceClient
		result2 error
	}
	networkServiceV2ReturnsOnCall map[int]struct {
		result1 *gophercloud.ServiceClient
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeOpenstackService) BlockStorageV3(arg1 config.OpenstackConfig) (*gophercloud.ServiceClient, error) {
	fake.blockStorageV3Mutex.Lock()
	ret, specificReturn := fake.blockStorageV3ReturnsOnCall[len(fake.blockStorageV3ArgsForCall)]
	fake.blockStorageV3ArgsForCall = append(fake.blockStorageV3ArgsForCall, struct {
		arg1 config.OpenstackConfig
	}{arg1})
	stub := fake.BlockStorageV3Stub
	fakeReturns := fake.blockStorageV3Returns
	fake.recordInvocation("BlockStorageV3", []interface{}{arg1})
	fake.blockStorageV3Mutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeOpenstackService) BlockStorageV3CallCount() int {
	fake.blockStorageV3Mutex.RLock()
	defer fake.blockStorageV3Mutex.RUnlock()
	return len(fake.blockStorageV3ArgsForCall)
}

func (fake *FakeOpenstackService) BlockStorageV3Calls(stub func(config.OpenstackConfig) (*gophercloud.ServiceClient, error)) {
	fake.blockStorageV3Mutex.Lock()
	defer fake.blockStorageV3Mutex.Unlock()
	fake.BlockStorageV3Stub = stub
}

func (fake *FakeOpenstackService) BlockStorageV3ArgsForCall(i int) config.OpenstackConfig {
	fake.blockStorageV3Mutex.RLock()
	defer fake.blockStorageV3Mutex.RUnlock()
	argsForCall := fake.blockStorageV3ArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeOpenstackService) BlockStorageV3Returns(result1 *gophercloud.ServiceClient, result2 error) {
	fake.blockStorageV3Mutex.Lock()
	defer fake.blockStorageV3Mutex.Unlock()
	fake.BlockStorageV3Stub = nil
	fake.blockStorageV3Returns = struct {
		result1 *gophercloud.ServiceClient
		result2 error
	}{result1, result2}
}

func (fake *FakeOpenstackService) BlockStorageV3ReturnsOnCall(i int, result1 *gophercloud.ServiceClient, result2 error) {
	fake.blockStorageV3Mutex.Lock()
	defer fake.blockStorageV3Mutex.Unlock()
	fake.BlockStorageV3Stub = nil
	if fake.blockStorageV3ReturnsOnCall == nil {
		fake.blockStorageV3ReturnsOnCall = make(map[int]struct {
			result1 *gophercloud.ServiceClient
			result2 error
		})
	}
	fake.blockStorageV3ReturnsOnCall[i] = struct {
		result1 *gophercloud.ServiceClient
		result2 error
	}{result1, result2}
}

func (fake *FakeOpenstackService) ComputeServiceV2(arg1 config.OpenstackConfig) (*gophercloud.ServiceClient, error) {
	fake.computeServiceV2Mutex.Lock()
	ret, specificReturn := fake.computeServiceV2ReturnsOnCall[len(fake.computeServiceV2ArgsForCall)]
	fake.computeServiceV2ArgsForCall = append(fake.computeServiceV2ArgsForCall, struct {
		arg1 config.OpenstackConfig
	}{arg1})
	stub := fake.ComputeServiceV2Stub
	fakeReturns := fake.computeServiceV2Returns
	fake.recordInvocation("ComputeServiceV2", []interface{}{arg1})
	fake.computeServiceV2Mutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeOpenstackService) ComputeServiceV2CallCount() int {
	fake.computeServiceV2Mutex.RLock()
	defer fake.computeServiceV2Mutex.RUnlock()
	return len(fake.computeServiceV2ArgsForCall)
}

func (fake *FakeOpenstackService) ComputeServiceV2Calls(stub func(config.OpenstackConfig) (*gophercloud.ServiceClient, error)) {
	fake.computeServiceV2Mutex.Lock()
	defer fake.computeServiceV2Mutex.Unlock()
	fake.ComputeServiceV2Stub = stub
}

func (fake *FakeOpenstackService) ComputeServiceV2ArgsForCall(i int) config.OpenstackConfig {
	fake.computeServiceV2Mutex.RLock()
	defer fake.computeServiceV2Mutex.RUnlock()
	argsForCall := fake.computeServiceV2ArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeOpenstackService) ComputeServiceV2Returns(result1 *gophercloud.ServiceClient, result2 error) {
	fake.computeServiceV2Mutex.Lock()
	defer fake.computeServiceV2Mutex.Unlock()
	fake.ComputeServiceV2Stub = nil
	fake.computeServiceV2Returns = struct {
		result1 *gophercloud.ServiceClient
		result2 error
	}{result1, result2}
}

func (fake *FakeOpenstackService) ComputeServiceV2ReturnsOnCall(i int, result1 *gophercloud.ServiceClient, result2 error) {
	fake.computeServiceV2Mutex.Lock()
	defer fake.computeServiceV2Mutex.Unlock()
	fake.ComputeServiceV2Stub = nil
	if fake.computeServiceV2ReturnsOnCall == nil {
		fake.computeServiceV2ReturnsOnCall = make(map[int]struct {
			result1 *gophercloud.ServiceClient
			result2 error
		})
	}
	fake.computeServiceV2ReturnsOnCall[i] = struct {
		result1 *gophercloud.ServiceClient
		result2 error
	}{result1, result2}
}

func (fake *FakeOpenstackService) ImageServiceV2(arg1 config.OpenstackConfig) (*gophercloud.ServiceClient, error) {
	fake.imageServiceV2Mutex.Lock()
	ret, specificReturn := fake.imageServiceV2ReturnsOnCall[len(fake.imageServiceV2ArgsForCall)]
	fake.imageServiceV2ArgsForCall = append(fake.imageServiceV2ArgsForCall, struct {
		arg1 config.OpenstackConfig
	}{arg1})
	stub := fake.ImageServiceV2Stub
	fakeReturns := fake.imageServiceV2Returns
	fake.recordInvocation("ImageServiceV2", []interface{}{arg1})
	fake.imageServiceV2Mutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeOpenstackService) ImageServiceV2CallCount() int {
	fake.imageServiceV2Mutex.RLock()
	defer fake.imageServiceV2Mutex.RUnlock()
	return len(fake.imageServiceV2ArgsForCall)
}

func (fake *FakeOpenstackService) ImageServiceV2Calls(stub func(config.OpenstackConfig) (*gophercloud.ServiceClient, error)) {
	fake.imageServiceV2Mutex.Lock()
	defer fake.imageServiceV2Mutex.Unlock()
	fake.ImageServiceV2Stub = stub
}

func (fake *FakeOpenstackService) ImageServiceV2ArgsForCall(i int) config.OpenstackConfig {
	fake.imageServiceV2Mutex.RLock()
	defer fake.imageServiceV2Mutex.RUnlock()
	argsForCall := fake.imageServiceV2ArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeOpenstackService) ImageServiceV2Returns(result1 *gophercloud.ServiceClient, result2 error) {
	fake.imageServiceV2Mutex.Lock()
	defer fake.imageServiceV2Mutex.Unlock()
	fake.ImageServiceV2Stub = nil
	fake.imageServiceV2Returns = struct {
		result1 *gophercloud.ServiceClient
		result2 error
	}{result1, result2}
}

func (fake *FakeOpenstackService) ImageServiceV2ReturnsOnCall(i int, result1 *gophercloud.ServiceClient, result2 error) {
	fake.imageServiceV2Mutex.Lock()
	defer fake.imageServiceV2Mutex.Unlock()
	fake.ImageServiceV2Stub = nil
	if fake.imageServiceV2ReturnsOnCall == nil {
		fake.imageServiceV2ReturnsOnCall = make(map[int]struct {
			result1 *gophercloud.ServiceClient
			result2 error
		})
	}
	fake.imageServiceV2ReturnsOnCall[i] = struct {
		result1 *gophercloud.ServiceClient
		result2 error
	}{result1, result2}
}

func (fake *FakeOpenstackService) LoadbalancerV2(arg1 config.OpenstackConfig) (*gophercloud.ServiceClient, error) {
	fake.loadbalancerV2Mutex.Lock()
	ret, specificReturn := fake.loadbalancerV2ReturnsOnCall[len(fake.loadbalancerV2ArgsForCall)]
	fake.loadbalancerV2ArgsForCall = append(fake.loadbalancerV2ArgsForCall, struct {
		arg1 config.OpenstackConfig
	}{arg1})
	stub := fake.LoadbalancerV2Stub
	fakeReturns := fake.loadbalancerV2Returns
	fake.recordInvocation("LoadbalancerV2", []interface{}{arg1})
	fake.loadbalancerV2Mutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeOpenstackService) LoadbalancerV2CallCount() int {
	fake.loadbalancerV2Mutex.RLock()
	defer fake.loadbalancerV2Mutex.RUnlock()
	return len(fake.loadbalancerV2ArgsForCall)
}

func (fake *FakeOpenstackService) LoadbalancerV2Calls(stub func(config.OpenstackConfig) (*gophercloud.ServiceClient, error)) {
	fake.loadbalancerV2Mutex.Lock()
	defer fake.loadbalancerV2Mutex.Unlock()
	fake.LoadbalancerV2Stub = stub
}

func (fake *FakeOpenstackService) LoadbalancerV2ArgsForCall(i int) config.OpenstackConfig {
	fake.loadbalancerV2Mutex.RLock()
	defer fake.loadbalancerV2Mutex.RUnlock()
	argsForCall := fake.loadbalancerV2ArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeOpenstackService) LoadbalancerV2Returns(result1 *gophercloud.ServiceClient, result2 error) {
	fake.loadbalancerV2Mutex.Lock()
	defer fake.loadbalancerV2Mutex.Unlock()
	fake.LoadbalancerV2Stub = nil
	fake.loadbalancerV2Returns = struct {
		result1 *gophercloud.ServiceClient
		result2 error
	}{result1, result2}
}

func (fake *FakeOpenstackService) LoadbalancerV2ReturnsOnCall(i int, result1 *gophercloud.ServiceClient, result2 error) {
	fake.loadbalancerV2Mutex.Lock()
	defer fake.loadbalancerV2Mutex.Unlock()
	fake.LoadbalancerV2Stub = nil
	if fake.loadbalancerV2ReturnsOnCall == nil {
		fake.loadbalancerV2ReturnsOnCall = make(map[int]struct {
			result1 *gophercloud.ServiceClient
			result2 error
		})
	}
	fake.loadbalancerV2ReturnsOnCall[i] = struct {
		result1 *gophercloud.ServiceClient
		result2 error
	}{result1, result2}
}

func (fake *FakeOpenstackService) NetworkServiceV2(arg1 config.OpenstackConfig) (*gophercloud.ServiceClient, error) {
	fake.networkServiceV2Mutex.Lock()
	ret, specificReturn := fake.networkServiceV2ReturnsOnCall[len(fake.networkServiceV2ArgsForCall)]
	fake.networkServiceV2ArgsForCall = append(fake.networkServiceV2ArgsForCall, struct {
		arg1 config.OpenstackConfig
	}{arg1})
	stub := fake.NetworkServiceV2Stub
	fakeReturns := fake.networkServiceV2Returns
	fake.recordInvocation("NetworkServiceV2", []interface{}{arg1})
	fake.networkServiceV2Mutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeOpenstackService) NetworkServiceV2CallCount() int {
	fake.networkServiceV2Mutex.RLock()
	defer fake.networkServiceV2Mutex.RUnlock()
	return len(fake.networkServiceV2ArgsForCall)
}

func (fake *FakeOpenstackService) NetworkServiceV2Calls(stub func(config.OpenstackConfig) (*gophercloud.ServiceClient, error)) {
	fake.networkServiceV2Mutex.Lock()
	defer fake.networkServiceV2Mutex.Unlock()
	fake.NetworkServiceV2Stub = stub
}

func (fake *FakeOpenstackService) NetworkServiceV2ArgsForCall(i int) config.OpenstackConfig {
	fake.networkServiceV2Mutex.RLock()
	defer fake.networkServiceV2Mutex.RUnlock()
	argsForCall := fake.networkServiceV2ArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeOpenstackService) NetworkServiceV2Returns(result1 *gophercloud.ServiceClient, result2 error) {
	fake.networkServiceV2Mutex.Lock()
	defer fake.networkServiceV2Mutex.Unlock()
	fake.NetworkServiceV2Stub = nil
	fake.networkServiceV2Returns = struct {
		result1 *gophercloud.ServiceClient
		result2 error
	}{result1, result2}
}

func (fake *FakeOpenstackService) NetworkServiceV2ReturnsOnCall(i int, result1 *gophercloud.ServiceClient, result2 error) {
	fake.networkServiceV2Mutex.Lock()
	defer fake.networkServiceV2Mutex.Unlock()
	fake.NetworkServiceV2Stub = nil
	if fake.networkServiceV2ReturnsOnCall == nil {
		fake.networkServiceV2ReturnsOnCall = make(map[int]struct {
			result1 *gophercloud.ServiceClient
			result2 error
		})
	}
	fake.networkServiceV2ReturnsOnCall[i] = struct {
		result1 *gophercloud.ServiceClient
		result2 error
	}{result1, result2}
}

func (fake *FakeOpenstackService) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.blockStorageV3Mutex.RLock()
	defer fake.blockStorageV3Mutex.RUnlock()
	fake.computeServiceV2Mutex.RLock()
	defer fake.computeServiceV2Mutex.RUnlock()
	fake.imageServiceV2Mutex.RLock()
	defer fake.imageServiceV2Mutex.RUnlock()
	fake.loadbalancerV2Mutex.RLock()
	defer fake.loadbalancerV2Mutex.RUnlock()
	fake.networkServiceV2Mutex.RLock()
	defer fake.networkServiceV2Mutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeOpenstackService) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ openstack.OpenstackService = new(FakeOpenstackService)
