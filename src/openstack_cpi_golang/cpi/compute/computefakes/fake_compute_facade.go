// Code generated by counterfeiter. DO NOT EDIT.
package computefakes

import (
	"sync"

	"github.com/cloudfoundry/bosh-openstack-cpi-release/src/openstack_cpi_golang/cpi/compute"
	"github.com/cloudfoundry/bosh-openstack-cpi-release/src/openstack_cpi_golang/cpi/utils"
	"github.com/gophercloud/gophercloud"
	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/keypairs"
	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/volumeattach"
	"github.com/gophercloud/gophercloud/openstack/compute/v2/flavors"
	"github.com/gophercloud/gophercloud/openstack/compute/v2/servers"
	"github.com/gophercloud/gophercloud/pagination"
)

type FakeComputeFacade struct {
	AttachVolumeStub        func(*gophercloud.ServiceClient, string, volumeattach.CreateOptsBuilder) (*volumeattach.VolumeAttachment, error)
	attachVolumeMutex       sync.RWMutex
	attachVolumeArgsForCall []struct {
		arg1 *gophercloud.ServiceClient
		arg2 string
		arg3 volumeattach.CreateOptsBuilder
	}
	attachVolumeReturns struct {
		result1 *volumeattach.VolumeAttachment
		result2 error
	}
	attachVolumeReturnsOnCall map[int]struct {
		result1 *volumeattach.VolumeAttachment
		result2 error
	}
	CreateServerStub        func(utils.ServiceClient, servers.CreateOptsBuilder) (*servers.Server, error)
	createServerMutex       sync.RWMutex
	createServerArgsForCall []struct {
		arg1 utils.ServiceClient
		arg2 servers.CreateOptsBuilder
	}
	createServerReturns struct {
		result1 *servers.Server
		result2 error
	}
	createServerReturnsOnCall map[int]struct {
		result1 *servers.Server
		result2 error
	}
	DeleteServerStub        func(utils.RetryableServiceClient, string) error
	deleteServerMutex       sync.RWMutex
	deleteServerArgsForCall []struct {
		arg1 utils.RetryableServiceClient
		arg2 string
	}
	deleteServerReturns struct {
		result1 error
	}
	deleteServerReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteServerMetaDataStub        func(*gophercloud.ServiceClient, string, string) error
	deleteServerMetaDataMutex       sync.RWMutex
	deleteServerMetaDataArgsForCall []struct {
		arg1 *gophercloud.ServiceClient
		arg2 string
		arg3 string
	}
	deleteServerMetaDataReturns struct {
		result1 error
	}
	deleteServerMetaDataReturnsOnCall map[int]struct {
		result1 error
	}
	DetachVolumeStub        func(*gophercloud.ServiceClient, string, string) error
	detachVolumeMutex       sync.RWMutex
	detachVolumeArgsForCall []struct {
		arg1 *gophercloud.ServiceClient
		arg2 string
		arg3 string
	}
	detachVolumeReturns struct {
		result1 error
	}
	detachVolumeReturnsOnCall map[int]struct {
		result1 error
	}
	ExtractFlavorsStub        func(pagination.Page) ([]flavors.Flavor, error)
	extractFlavorsMutex       sync.RWMutex
	extractFlavorsArgsForCall []struct {
		arg1 pagination.Page
	}
	extractFlavorsReturns struct {
		result1 []flavors.Flavor
		result2 error
	}
	extractFlavorsReturnsOnCall map[int]struct {
		result1 []flavors.Flavor
		result2 error
	}
	GetOSKeyPairStub        func(utils.RetryableServiceClient, string, keypairs.GetOpts) (*keypairs.KeyPair, error)
	getOSKeyPairMutex       sync.RWMutex
	getOSKeyPairArgsForCall []struct {
		arg1 utils.RetryableServiceClient
		arg2 string
		arg3 keypairs.GetOpts
	}
	getOSKeyPairReturns struct {
		result1 *keypairs.KeyPair
		result2 error
	}
	getOSKeyPairReturnsOnCall map[int]struct {
		result1 *keypairs.KeyPair
		result2 error
	}
	GetServerStub        func(utils.RetryableServiceClient, string) (*servers.Server, error)
	getServerMutex       sync.RWMutex
	getServerArgsForCall []struct {
		arg1 utils.RetryableServiceClient
		arg2 string
	}
	getServerReturns struct {
		result1 *servers.Server
		result2 error
	}
	getServerReturnsOnCall map[int]struct {
		result1 *servers.Server
		result2 error
	}
	GetServerMetadataStub        func(utils.RetryableServiceClient, string) (map[string]string, error)
	getServerMetadataMutex       sync.RWMutex
	getServerMetadataArgsForCall []struct {
		arg1 utils.RetryableServiceClient
		arg2 string
	}
	getServerMetadataReturns struct {
		result1 map[string]string
		result2 error
	}
	getServerMetadataReturnsOnCall map[int]struct {
		result1 map[string]string
		result2 error
	}
	GetServerWithAZStub        func(utils.RetryableServiceClient, string) (*compute.ServerWithAZ, error)
	getServerWithAZMutex       sync.RWMutex
	getServerWithAZArgsForCall []struct {
		arg1 utils.RetryableServiceClient
		arg2 string
	}
	getServerWithAZReturns struct {
		result1 *compute.ServerWithAZ
		result2 error
	}
	getServerWithAZReturnsOnCall map[int]struct {
		result1 *compute.ServerWithAZ
		result2 error
	}
	ListFlavorsStub        func(utils.RetryableServiceClient, flavors.ListOpts) (pagination.Page, error)
	listFlavorsMutex       sync.RWMutex
	listFlavorsArgsForCall []struct {
		arg1 utils.RetryableServiceClient
		arg2 flavors.ListOpts
	}
	listFlavorsReturns struct {
		result1 pagination.Page
		result2 error
	}
	listFlavorsReturnsOnCall map[int]struct {
		result1 pagination.Page
		result2 error
	}
	ListVolumeAttachmentsStub        func(*gophercloud.ServiceClient, string) ([]volumeattach.VolumeAttachment, error)
	listVolumeAttachmentsMutex       sync.RWMutex
	listVolumeAttachmentsArgsForCall []struct {
		arg1 *gophercloud.ServiceClient
		arg2 string
	}
	listVolumeAttachmentsReturns struct {
		result1 []volumeattach.VolumeAttachment
		result2 error
	}
	listVolumeAttachmentsReturnsOnCall map[int]struct {
		result1 []volumeattach.VolumeAttachment
		result2 error
	}
	RebootServerStub        func(utils.ServiceClient, string, servers.RebootOptsBuilder) error
	rebootServerMutex       sync.RWMutex
	rebootServerArgsForCall []struct {
		arg1 utils.ServiceClient
		arg2 string
		arg3 servers.RebootOptsBuilder
	}
	rebootServerReturns struct {
		result1 error
	}
	rebootServerReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateServerStub        func(utils.ServiceClient, string, servers.UpdateOptsBuilder) (*servers.Server, error)
	updateServerMutex       sync.RWMutex
	updateServerArgsForCall []struct {
		arg1 utils.ServiceClient
		arg2 string
		arg3 servers.UpdateOptsBuilder
	}
	updateServerReturns struct {
		result1 *servers.Server
		result2 error
	}
	updateServerReturnsOnCall map[int]struct {
		result1 *servers.Server
		result2 error
	}
	UpdateServerMetadataStub        func(utils.ServiceClient, string, servers.UpdateMetadataOptsBuilder) (map[string]string, error)
	updateServerMetadataMutex       sync.RWMutex
	updateServerMetadataArgsForCall []struct {
		arg1 utils.ServiceClient
		arg2 string
		arg3 servers.UpdateMetadataOptsBuilder
	}
	updateServerMetadataReturns struct {
		result1 map[string]string
		result2 error
	}
	updateServerMetadataReturnsOnCall map[int]struct {
		result1 map[string]string
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeComputeFacade) AttachVolume(arg1 *gophercloud.ServiceClient, arg2 string, arg3 volumeattach.CreateOptsBuilder) (*volumeattach.VolumeAttachment, error) {
	fake.attachVolumeMutex.Lock()
	ret, specificReturn := fake.attachVolumeReturnsOnCall[len(fake.attachVolumeArgsForCall)]
	fake.attachVolumeArgsForCall = append(fake.attachVolumeArgsForCall, struct {
		arg1 *gophercloud.ServiceClient
		arg2 string
		arg3 volumeattach.CreateOptsBuilder
	}{arg1, arg2, arg3})
	stub := fake.AttachVolumeStub
	fakeReturns := fake.attachVolumeReturns
	fake.recordInvocation("AttachVolume", []interface{}{arg1, arg2, arg3})
	fake.attachVolumeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeComputeFacade) AttachVolumeCallCount() int {
	fake.attachVolumeMutex.RLock()
	defer fake.attachVolumeMutex.RUnlock()
	return len(fake.attachVolumeArgsForCall)
}

func (fake *FakeComputeFacade) AttachVolumeCalls(stub func(*gophercloud.ServiceClient, string, volumeattach.CreateOptsBuilder) (*volumeattach.VolumeAttachment, error)) {
	fake.attachVolumeMutex.Lock()
	defer fake.attachVolumeMutex.Unlock()
	fake.AttachVolumeStub = stub
}

func (fake *FakeComputeFacade) AttachVolumeArgsForCall(i int) (*gophercloud.ServiceClient, string, volumeattach.CreateOptsBuilder) {
	fake.attachVolumeMutex.RLock()
	defer fake.attachVolumeMutex.RUnlock()
	argsForCall := fake.attachVolumeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeComputeFacade) AttachVolumeReturns(result1 *volumeattach.VolumeAttachment, result2 error) {
	fake.attachVolumeMutex.Lock()
	defer fake.attachVolumeMutex.Unlock()
	fake.AttachVolumeStub = nil
	fake.attachVolumeReturns = struct {
		result1 *volumeattach.VolumeAttachment
		result2 error
	}{result1, result2}
}

func (fake *FakeComputeFacade) AttachVolumeReturnsOnCall(i int, result1 *volumeattach.VolumeAttachment, result2 error) {
	fake.attachVolumeMutex.Lock()
	defer fake.attachVolumeMutex.Unlock()
	fake.AttachVolumeStub = nil
	if fake.attachVolumeReturnsOnCall == nil {
		fake.attachVolumeReturnsOnCall = make(map[int]struct {
			result1 *volumeattach.VolumeAttachment
			result2 error
		})
	}
	fake.attachVolumeReturnsOnCall[i] = struct {
		result1 *volumeattach.VolumeAttachment
		result2 error
	}{result1, result2}
}

func (fake *FakeComputeFacade) CreateServer(arg1 utils.ServiceClient, arg2 servers.CreateOptsBuilder) (*servers.Server, error) {
	fake.createServerMutex.Lock()
	ret, specificReturn := fake.createServerReturnsOnCall[len(fake.createServerArgsForCall)]
	fake.createServerArgsForCall = append(fake.createServerArgsForCall, struct {
		arg1 utils.ServiceClient
		arg2 servers.CreateOptsBuilder
	}{arg1, arg2})
	stub := fake.CreateServerStub
	fakeReturns := fake.createServerReturns
	fake.recordInvocation("CreateServer", []interface{}{arg1, arg2})
	fake.createServerMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeComputeFacade) CreateServerCallCount() int {
	fake.createServerMutex.RLock()
	defer fake.createServerMutex.RUnlock()
	return len(fake.createServerArgsForCall)
}

func (fake *FakeComputeFacade) CreateServerCalls(stub func(utils.ServiceClient, servers.CreateOptsBuilder) (*servers.Server, error)) {
	fake.createServerMutex.Lock()
	defer fake.createServerMutex.Unlock()
	fake.CreateServerStub = stub
}

func (fake *FakeComputeFacade) CreateServerArgsForCall(i int) (utils.ServiceClient, servers.CreateOptsBuilder) {
	fake.createServerMutex.RLock()
	defer fake.createServerMutex.RUnlock()
	argsForCall := fake.createServerArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeComputeFacade) CreateServerReturns(result1 *servers.Server, result2 error) {
	fake.createServerMutex.Lock()
	defer fake.createServerMutex.Unlock()
	fake.CreateServerStub = nil
	fake.createServerReturns = struct {
		result1 *servers.Server
		result2 error
	}{result1, result2}
}

func (fake *FakeComputeFacade) CreateServerReturnsOnCall(i int, result1 *servers.Server, result2 error) {
	fake.createServerMutex.Lock()
	defer fake.createServerMutex.Unlock()
	fake.CreateServerStub = nil
	if fake.createServerReturnsOnCall == nil {
		fake.createServerReturnsOnCall = make(map[int]struct {
			result1 *servers.Server
			result2 error
		})
	}
	fake.createServerReturnsOnCall[i] = struct {
		result1 *servers.Server
		result2 error
	}{result1, result2}
}

func (fake *FakeComputeFacade) DeleteServer(arg1 utils.RetryableServiceClient, arg2 string) error {
	fake.deleteServerMutex.Lock()
	ret, specificReturn := fake.deleteServerReturnsOnCall[len(fake.deleteServerArgsForCall)]
	fake.deleteServerArgsForCall = append(fake.deleteServerArgsForCall, struct {
		arg1 utils.RetryableServiceClient
		arg2 string
	}{arg1, arg2})
	stub := fake.DeleteServerStub
	fakeReturns := fake.deleteServerReturns
	fake.recordInvocation("DeleteServer", []interface{}{arg1, arg2})
	fake.deleteServerMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeComputeFacade) DeleteServerCallCount() int {
	fake.deleteServerMutex.RLock()
	defer fake.deleteServerMutex.RUnlock()
	return len(fake.deleteServerArgsForCall)
}

func (fake *FakeComputeFacade) DeleteServerCalls(stub func(utils.RetryableServiceClient, string) error) {
	fake.deleteServerMutex.Lock()
	defer fake.deleteServerMutex.Unlock()
	fake.DeleteServerStub = stub
}

func (fake *FakeComputeFacade) DeleteServerArgsForCall(i int) (utils.RetryableServiceClient, string) {
	fake.deleteServerMutex.RLock()
	defer fake.deleteServerMutex.RUnlock()
	argsForCall := fake.deleteServerArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeComputeFacade) DeleteServerReturns(result1 error) {
	fake.deleteServerMutex.Lock()
	defer fake.deleteServerMutex.Unlock()
	fake.DeleteServerStub = nil
	fake.deleteServerReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeComputeFacade) DeleteServerReturnsOnCall(i int, result1 error) {
	fake.deleteServerMutex.Lock()
	defer fake.deleteServerMutex.Unlock()
	fake.DeleteServerStub = nil
	if fake.deleteServerReturnsOnCall == nil {
		fake.deleteServerReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteServerReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeComputeFacade) DeleteServerMetaData(arg1 *gophercloud.ServiceClient, arg2 string, arg3 string) error {
	fake.deleteServerMetaDataMutex.Lock()
	ret, specificReturn := fake.deleteServerMetaDataReturnsOnCall[len(fake.deleteServerMetaDataArgsForCall)]
	fake.deleteServerMetaDataArgsForCall = append(fake.deleteServerMetaDataArgsForCall, struct {
		arg1 *gophercloud.ServiceClient
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.DeleteServerMetaDataStub
	fakeReturns := fake.deleteServerMetaDataReturns
	fake.recordInvocation("DeleteServerMetaData", []interface{}{arg1, arg2, arg3})
	fake.deleteServerMetaDataMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeComputeFacade) DeleteServerMetaDataCallCount() int {
	fake.deleteServerMetaDataMutex.RLock()
	defer fake.deleteServerMetaDataMutex.RUnlock()
	return len(fake.deleteServerMetaDataArgsForCall)
}

func (fake *FakeComputeFacade) DeleteServerMetaDataCalls(stub func(*gophercloud.ServiceClient, string, string) error) {
	fake.deleteServerMetaDataMutex.Lock()
	defer fake.deleteServerMetaDataMutex.Unlock()
	fake.DeleteServerMetaDataStub = stub
}

func (fake *FakeComputeFacade) DeleteServerMetaDataArgsForCall(i int) (*gophercloud.ServiceClient, string, string) {
	fake.deleteServerMetaDataMutex.RLock()
	defer fake.deleteServerMetaDataMutex.RUnlock()
	argsForCall := fake.deleteServerMetaDataArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeComputeFacade) DeleteServerMetaDataReturns(result1 error) {
	fake.deleteServerMetaDataMutex.Lock()
	defer fake.deleteServerMetaDataMutex.Unlock()
	fake.DeleteServerMetaDataStub = nil
	fake.deleteServerMetaDataReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeComputeFacade) DeleteServerMetaDataReturnsOnCall(i int, result1 error) {
	fake.deleteServerMetaDataMutex.Lock()
	defer fake.deleteServerMetaDataMutex.Unlock()
	fake.DeleteServerMetaDataStub = nil
	if fake.deleteServerMetaDataReturnsOnCall == nil {
		fake.deleteServerMetaDataReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteServerMetaDataReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeComputeFacade) DetachVolume(arg1 *gophercloud.ServiceClient, arg2 string, arg3 string) error {
	fake.detachVolumeMutex.Lock()
	ret, specificReturn := fake.detachVolumeReturnsOnCall[len(fake.detachVolumeArgsForCall)]
	fake.detachVolumeArgsForCall = append(fake.detachVolumeArgsForCall, struct {
		arg1 *gophercloud.ServiceClient
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.DetachVolumeStub
	fakeReturns := fake.detachVolumeReturns
	fake.recordInvocation("DetachVolume", []interface{}{arg1, arg2, arg3})
	fake.detachVolumeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeComputeFacade) DetachVolumeCallCount() int {
	fake.detachVolumeMutex.RLock()
	defer fake.detachVolumeMutex.RUnlock()
	return len(fake.detachVolumeArgsForCall)
}

func (fake *FakeComputeFacade) DetachVolumeCalls(stub func(*gophercloud.ServiceClient, string, string) error) {
	fake.detachVolumeMutex.Lock()
	defer fake.detachVolumeMutex.Unlock()
	fake.DetachVolumeStub = stub
}

func (fake *FakeComputeFacade) DetachVolumeArgsForCall(i int) (*gophercloud.ServiceClient, string, string) {
	fake.detachVolumeMutex.RLock()
	defer fake.detachVolumeMutex.RUnlock()
	argsForCall := fake.detachVolumeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeComputeFacade) DetachVolumeReturns(result1 error) {
	fake.detachVolumeMutex.Lock()
	defer fake.detachVolumeMutex.Unlock()
	fake.DetachVolumeStub = nil
	fake.detachVolumeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeComputeFacade) DetachVolumeReturnsOnCall(i int, result1 error) {
	fake.detachVolumeMutex.Lock()
	defer fake.detachVolumeMutex.Unlock()
	fake.DetachVolumeStub = nil
	if fake.detachVolumeReturnsOnCall == nil {
		fake.detachVolumeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.detachVolumeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeComputeFacade) ExtractFlavors(arg1 pagination.Page) ([]flavors.Flavor, error) {
	fake.extractFlavorsMutex.Lock()
	ret, specificReturn := fake.extractFlavorsReturnsOnCall[len(fake.extractFlavorsArgsForCall)]
	fake.extractFlavorsArgsForCall = append(fake.extractFlavorsArgsForCall, struct {
		arg1 pagination.Page
	}{arg1})
	stub := fake.ExtractFlavorsStub
	fakeReturns := fake.extractFlavorsReturns
	fake.recordInvocation("ExtractFlavors", []interface{}{arg1})
	fake.extractFlavorsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeComputeFacade) ExtractFlavorsCallCount() int {
	fake.extractFlavorsMutex.RLock()
	defer fake.extractFlavorsMutex.RUnlock()
	return len(fake.extractFlavorsArgsForCall)
}

func (fake *FakeComputeFacade) ExtractFlavorsCalls(stub func(pagination.Page) ([]flavors.Flavor, error)) {
	fake.extractFlavorsMutex.Lock()
	defer fake.extractFlavorsMutex.Unlock()
	fake.ExtractFlavorsStub = stub
}

func (fake *FakeComputeFacade) ExtractFlavorsArgsForCall(i int) pagination.Page {
	fake.extractFlavorsMutex.RLock()
	defer fake.extractFlavorsMutex.RUnlock()
	argsForCall := fake.extractFlavorsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeComputeFacade) ExtractFlavorsReturns(result1 []flavors.Flavor, result2 error) {
	fake.extractFlavorsMutex.Lock()
	defer fake.extractFlavorsMutex.Unlock()
	fake.ExtractFlavorsStub = nil
	fake.extractFlavorsReturns = struct {
		result1 []flavors.Flavor
		result2 error
	}{result1, result2}
}

func (fake *FakeComputeFacade) ExtractFlavorsReturnsOnCall(i int, result1 []flavors.Flavor, result2 error) {
	fake.extractFlavorsMutex.Lock()
	defer fake.extractFlavorsMutex.Unlock()
	fake.ExtractFlavorsStub = nil
	if fake.extractFlavorsReturnsOnCall == nil {
		fake.extractFlavorsReturnsOnCall = make(map[int]struct {
			result1 []flavors.Flavor
			result2 error
		})
	}
	fake.extractFlavorsReturnsOnCall[i] = struct {
		result1 []flavors.Flavor
		result2 error
	}{result1, result2}
}

func (fake *FakeComputeFacade) GetOSKeyPair(arg1 utils.RetryableServiceClient, arg2 string, arg3 keypairs.GetOpts) (*keypairs.KeyPair, error) {
	fake.getOSKeyPairMutex.Lock()
	ret, specificReturn := fake.getOSKeyPairReturnsOnCall[len(fake.getOSKeyPairArgsForCall)]
	fake.getOSKeyPairArgsForCall = append(fake.getOSKeyPairArgsForCall, struct {
		arg1 utils.RetryableServiceClient
		arg2 string
		arg3 keypairs.GetOpts
	}{arg1, arg2, arg3})
	stub := fake.GetOSKeyPairStub
	fakeReturns := fake.getOSKeyPairReturns
	fake.recordInvocation("GetOSKeyPair", []interface{}{arg1, arg2, arg3})
	fake.getOSKeyPairMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeComputeFacade) GetOSKeyPairCallCount() int {
	fake.getOSKeyPairMutex.RLock()
	defer fake.getOSKeyPairMutex.RUnlock()
	return len(fake.getOSKeyPairArgsForCall)
}

func (fake *FakeComputeFacade) GetOSKeyPairCalls(stub func(utils.RetryableServiceClient, string, keypairs.GetOpts) (*keypairs.KeyPair, error)) {
	fake.getOSKeyPairMutex.Lock()
	defer fake.getOSKeyPairMutex.Unlock()
	fake.GetOSKeyPairStub = stub
}

func (fake *FakeComputeFacade) GetOSKeyPairArgsForCall(i int) (utils.RetryableServiceClient, string, keypairs.GetOpts) {
	fake.getOSKeyPairMutex.RLock()
	defer fake.getOSKeyPairMutex.RUnlock()
	argsForCall := fake.getOSKeyPairArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeComputeFacade) GetOSKeyPairReturns(result1 *keypairs.KeyPair, result2 error) {
	fake.getOSKeyPairMutex.Lock()
	defer fake.getOSKeyPairMutex.Unlock()
	fake.GetOSKeyPairStub = nil
	fake.getOSKeyPairReturns = struct {
		result1 *keypairs.KeyPair
		result2 error
	}{result1, result2}
}

func (fake *FakeComputeFacade) GetOSKeyPairReturnsOnCall(i int, result1 *keypairs.KeyPair, result2 error) {
	fake.getOSKeyPairMutex.Lock()
	defer fake.getOSKeyPairMutex.Unlock()
	fake.GetOSKeyPairStub = nil
	if fake.getOSKeyPairReturnsOnCall == nil {
		fake.getOSKeyPairReturnsOnCall = make(map[int]struct {
			result1 *keypairs.KeyPair
			result2 error
		})
	}
	fake.getOSKeyPairReturnsOnCall[i] = struct {
		result1 *keypairs.KeyPair
		result2 error
	}{result1, result2}
}

func (fake *FakeComputeFacade) GetServer(arg1 utils.RetryableServiceClient, arg2 string) (*servers.Server, error) {
	fake.getServerMutex.Lock()
	ret, specificReturn := fake.getServerReturnsOnCall[len(fake.getServerArgsForCall)]
	fake.getServerArgsForCall = append(fake.getServerArgsForCall, struct {
		arg1 utils.RetryableServiceClient
		arg2 string
	}{arg1, arg2})
	stub := fake.GetServerStub
	fakeReturns := fake.getServerReturns
	fake.recordInvocation("GetServer", []interface{}{arg1, arg2})
	fake.getServerMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeComputeFacade) GetServerCallCount() int {
	fake.getServerMutex.RLock()
	defer fake.getServerMutex.RUnlock()
	return len(fake.getServerArgsForCall)
}

func (fake *FakeComputeFacade) GetServerCalls(stub func(utils.RetryableServiceClient, string) (*servers.Server, error)) {
	fake.getServerMutex.Lock()
	defer fake.getServerMutex.Unlock()
	fake.GetServerStub = stub
}

func (fake *FakeComputeFacade) GetServerArgsForCall(i int) (utils.RetryableServiceClient, string) {
	fake.getServerMutex.RLock()
	defer fake.getServerMutex.RUnlock()
	argsForCall := fake.getServerArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeComputeFacade) GetServerReturns(result1 *servers.Server, result2 error) {
	fake.getServerMutex.Lock()
	defer fake.getServerMutex.Unlock()
	fake.GetServerStub = nil
	fake.getServerReturns = struct {
		result1 *servers.Server
		result2 error
	}{result1, result2}
}

func (fake *FakeComputeFacade) GetServerReturnsOnCall(i int, result1 *servers.Server, result2 error) {
	fake.getServerMutex.Lock()
	defer fake.getServerMutex.Unlock()
	fake.GetServerStub = nil
	if fake.getServerReturnsOnCall == nil {
		fake.getServerReturnsOnCall = make(map[int]struct {
			result1 *servers.Server
			result2 error
		})
	}
	fake.getServerReturnsOnCall[i] = struct {
		result1 *servers.Server
		result2 error
	}{result1, result2}
}

func (fake *FakeComputeFacade) GetServerMetadata(arg1 utils.RetryableServiceClient, arg2 string) (map[string]string, error) {
	fake.getServerMetadataMutex.Lock()
	ret, specificReturn := fake.getServerMetadataReturnsOnCall[len(fake.getServerMetadataArgsForCall)]
	fake.getServerMetadataArgsForCall = append(fake.getServerMetadataArgsForCall, struct {
		arg1 utils.RetryableServiceClient
		arg2 string
	}{arg1, arg2})
	stub := fake.GetServerMetadataStub
	fakeReturns := fake.getServerMetadataReturns
	fake.recordInvocation("GetServerMetadata", []interface{}{arg1, arg2})
	fake.getServerMetadataMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeComputeFacade) GetServerMetadataCallCount() int {
	fake.getServerMetadataMutex.RLock()
	defer fake.getServerMetadataMutex.RUnlock()
	return len(fake.getServerMetadataArgsForCall)
}

func (fake *FakeComputeFacade) GetServerMetadataCalls(stub func(utils.RetryableServiceClient, string) (map[string]string, error)) {
	fake.getServerMetadataMutex.Lock()
	defer fake.getServerMetadataMutex.Unlock()
	fake.GetServerMetadataStub = stub
}

func (fake *FakeComputeFacade) GetServerMetadataArgsForCall(i int) (utils.RetryableServiceClient, string) {
	fake.getServerMetadataMutex.RLock()
	defer fake.getServerMetadataMutex.RUnlock()
	argsForCall := fake.getServerMetadataArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeComputeFacade) GetServerMetadataReturns(result1 map[string]string, result2 error) {
	fake.getServerMetadataMutex.Lock()
	defer fake.getServerMetadataMutex.Unlock()
	fake.GetServerMetadataStub = nil
	fake.getServerMetadataReturns = struct {
		result1 map[string]string
		result2 error
	}{result1, result2}
}

func (fake *FakeComputeFacade) GetServerMetadataReturnsOnCall(i int, result1 map[string]string, result2 error) {
	fake.getServerMetadataMutex.Lock()
	defer fake.getServerMetadataMutex.Unlock()
	fake.GetServerMetadataStub = nil
	if fake.getServerMetadataReturnsOnCall == nil {
		fake.getServerMetadataReturnsOnCall = make(map[int]struct {
			result1 map[string]string
			result2 error
		})
	}
	fake.getServerMetadataReturnsOnCall[i] = struct {
		result1 map[string]string
		result2 error
	}{result1, result2}
}

func (fake *FakeComputeFacade) GetServerWithAZ(arg1 utils.RetryableServiceClient, arg2 string) (*compute.ServerWithAZ, error) {
	fake.getServerWithAZMutex.Lock()
	ret, specificReturn := fake.getServerWithAZReturnsOnCall[len(fake.getServerWithAZArgsForCall)]
	fake.getServerWithAZArgsForCall = append(fake.getServerWithAZArgsForCall, struct {
		arg1 utils.RetryableServiceClient
		arg2 string
	}{arg1, arg2})
	stub := fake.GetServerWithAZStub
	fakeReturns := fake.getServerWithAZReturns
	fake.recordInvocation("GetServerWithAZ", []interface{}{arg1, arg2})
	fake.getServerWithAZMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeComputeFacade) GetServerWithAZCallCount() int {
	fake.getServerWithAZMutex.RLock()
	defer fake.getServerWithAZMutex.RUnlock()
	return len(fake.getServerWithAZArgsForCall)
}

func (fake *FakeComputeFacade) GetServerWithAZCalls(stub func(utils.RetryableServiceClient, string) (*compute.ServerWithAZ, error)) {
	fake.getServerWithAZMutex.Lock()
	defer fake.getServerWithAZMutex.Unlock()
	fake.GetServerWithAZStub = stub
}

func (fake *FakeComputeFacade) GetServerWithAZArgsForCall(i int) (utils.RetryableServiceClient, string) {
	fake.getServerWithAZMutex.RLock()
	defer fake.getServerWithAZMutex.RUnlock()
	argsForCall := fake.getServerWithAZArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeComputeFacade) GetServerWithAZReturns(result1 *compute.ServerWithAZ, result2 error) {
	fake.getServerWithAZMutex.Lock()
	defer fake.getServerWithAZMutex.Unlock()
	fake.GetServerWithAZStub = nil
	fake.getServerWithAZReturns = struct {
		result1 *compute.ServerWithAZ
		result2 error
	}{result1, result2}
}

func (fake *FakeComputeFacade) GetServerWithAZReturnsOnCall(i int, result1 *compute.ServerWithAZ, result2 error) {
	fake.getServerWithAZMutex.Lock()
	defer fake.getServerWithAZMutex.Unlock()
	fake.GetServerWithAZStub = nil
	if fake.getServerWithAZReturnsOnCall == nil {
		fake.getServerWithAZReturnsOnCall = make(map[int]struct {
			result1 *compute.ServerWithAZ
			result2 error
		})
	}
	fake.getServerWithAZReturnsOnCall[i] = struct {
		result1 *compute.ServerWithAZ
		result2 error
	}{result1, result2}
}

func (fake *FakeComputeFacade) ListFlavors(arg1 utils.RetryableServiceClient, arg2 flavors.ListOpts) (pagination.Page, error) {
	fake.listFlavorsMutex.Lock()
	ret, specificReturn := fake.listFlavorsReturnsOnCall[len(fake.listFlavorsArgsForCall)]
	fake.listFlavorsArgsForCall = append(fake.listFlavorsArgsForCall, struct {
		arg1 utils.RetryableServiceClient
		arg2 flavors.ListOpts
	}{arg1, arg2})
	stub := fake.ListFlavorsStub
	fakeReturns := fake.listFlavorsReturns
	fake.recordInvocation("ListFlavors", []interface{}{arg1, arg2})
	fake.listFlavorsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeComputeFacade) ListFlavorsCallCount() int {
	fake.listFlavorsMutex.RLock()
	defer fake.listFlavorsMutex.RUnlock()
	return len(fake.listFlavorsArgsForCall)
}

func (fake *FakeComputeFacade) ListFlavorsCalls(stub func(utils.RetryableServiceClient, flavors.ListOpts) (pagination.Page, error)) {
	fake.listFlavorsMutex.Lock()
	defer fake.listFlavorsMutex.Unlock()
	fake.ListFlavorsStub = stub
}

func (fake *FakeComputeFacade) ListFlavorsArgsForCall(i int) (utils.RetryableServiceClient, flavors.ListOpts) {
	fake.listFlavorsMutex.RLock()
	defer fake.listFlavorsMutex.RUnlock()
	argsForCall := fake.listFlavorsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeComputeFacade) ListFlavorsReturns(result1 pagination.Page, result2 error) {
	fake.listFlavorsMutex.Lock()
	defer fake.listFlavorsMutex.Unlock()
	fake.ListFlavorsStub = nil
	fake.listFlavorsReturns = struct {
		result1 pagination.Page
		result2 error
	}{result1, result2}
}

func (fake *FakeComputeFacade) ListFlavorsReturnsOnCall(i int, result1 pagination.Page, result2 error) {
	fake.listFlavorsMutex.Lock()
	defer fake.listFlavorsMutex.Unlock()
	fake.ListFlavorsStub = nil
	if fake.listFlavorsReturnsOnCall == nil {
		fake.listFlavorsReturnsOnCall = make(map[int]struct {
			result1 pagination.Page
			result2 error
		})
	}
	fake.listFlavorsReturnsOnCall[i] = struct {
		result1 pagination.Page
		result2 error
	}{result1, result2}
}

func (fake *FakeComputeFacade) ListVolumeAttachments(arg1 *gophercloud.ServiceClient, arg2 string) ([]volumeattach.VolumeAttachment, error) {
	fake.listVolumeAttachmentsMutex.Lock()
	ret, specificReturn := fake.listVolumeAttachmentsReturnsOnCall[len(fake.listVolumeAttachmentsArgsForCall)]
	fake.listVolumeAttachmentsArgsForCall = append(fake.listVolumeAttachmentsArgsForCall, struct {
		arg1 *gophercloud.ServiceClient
		arg2 string
	}{arg1, arg2})
	stub := fake.ListVolumeAttachmentsStub
	fakeReturns := fake.listVolumeAttachmentsReturns
	fake.recordInvocation("ListVolumeAttachments", []interface{}{arg1, arg2})
	fake.listVolumeAttachmentsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeComputeFacade) ListVolumeAttachmentsCallCount() int {
	fake.listVolumeAttachmentsMutex.RLock()
	defer fake.listVolumeAttachmentsMutex.RUnlock()
	return len(fake.listVolumeAttachmentsArgsForCall)
}

func (fake *FakeComputeFacade) ListVolumeAttachmentsCalls(stub func(*gophercloud.ServiceClient, string) ([]volumeattach.VolumeAttachment, error)) {
	fake.listVolumeAttachmentsMutex.Lock()
	defer fake.listVolumeAttachmentsMutex.Unlock()
	fake.ListVolumeAttachmentsStub = stub
}

func (fake *FakeComputeFacade) ListVolumeAttachmentsArgsForCall(i int) (*gophercloud.ServiceClient, string) {
	fake.listVolumeAttachmentsMutex.RLock()
	defer fake.listVolumeAttachmentsMutex.RUnlock()
	argsForCall := fake.listVolumeAttachmentsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeComputeFacade) ListVolumeAttachmentsReturns(result1 []volumeattach.VolumeAttachment, result2 error) {
	fake.listVolumeAttachmentsMutex.Lock()
	defer fake.listVolumeAttachmentsMutex.Unlock()
	fake.ListVolumeAttachmentsStub = nil
	fake.listVolumeAttachmentsReturns = struct {
		result1 []volumeattach.VolumeAttachment
		result2 error
	}{result1, result2}
}

func (fake *FakeComputeFacade) ListVolumeAttachmentsReturnsOnCall(i int, result1 []volumeattach.VolumeAttachment, result2 error) {
	fake.listVolumeAttachmentsMutex.Lock()
	defer fake.listVolumeAttachmentsMutex.Unlock()
	fake.ListVolumeAttachmentsStub = nil
	if fake.listVolumeAttachmentsReturnsOnCall == nil {
		fake.listVolumeAttachmentsReturnsOnCall = make(map[int]struct {
			result1 []volumeattach.VolumeAttachment
			result2 error
		})
	}
	fake.listVolumeAttachmentsReturnsOnCall[i] = struct {
		result1 []volumeattach.VolumeAttachment
		result2 error
	}{result1, result2}
}

func (fake *FakeComputeFacade) RebootServer(arg1 utils.ServiceClient, arg2 string, arg3 servers.RebootOptsBuilder) error {
	fake.rebootServerMutex.Lock()
	ret, specificReturn := fake.rebootServerReturnsOnCall[len(fake.rebootServerArgsForCall)]
	fake.rebootServerArgsForCall = append(fake.rebootServerArgsForCall, struct {
		arg1 utils.ServiceClient
		arg2 string
		arg3 servers.RebootOptsBuilder
	}{arg1, arg2, arg3})
	stub := fake.RebootServerStub
	fakeReturns := fake.rebootServerReturns
	fake.recordInvocation("RebootServer", []interface{}{arg1, arg2, arg3})
	fake.rebootServerMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeComputeFacade) RebootServerCallCount() int {
	fake.rebootServerMutex.RLock()
	defer fake.rebootServerMutex.RUnlock()
	return len(fake.rebootServerArgsForCall)
}

func (fake *FakeComputeFacade) RebootServerCalls(stub func(utils.ServiceClient, string, servers.RebootOptsBuilder) error) {
	fake.rebootServerMutex.Lock()
	defer fake.rebootServerMutex.Unlock()
	fake.RebootServerStub = stub
}

func (fake *FakeComputeFacade) RebootServerArgsForCall(i int) (utils.ServiceClient, string, servers.RebootOptsBuilder) {
	fake.rebootServerMutex.RLock()
	defer fake.rebootServerMutex.RUnlock()
	argsForCall := fake.rebootServerArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeComputeFacade) RebootServerReturns(result1 error) {
	fake.rebootServerMutex.Lock()
	defer fake.rebootServerMutex.Unlock()
	fake.RebootServerStub = nil
	fake.rebootServerReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeComputeFacade) RebootServerReturnsOnCall(i int, result1 error) {
	fake.rebootServerMutex.Lock()
	defer fake.rebootServerMutex.Unlock()
	fake.RebootServerStub = nil
	if fake.rebootServerReturnsOnCall == nil {
		fake.rebootServerReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.rebootServerReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeComputeFacade) UpdateServer(arg1 utils.ServiceClient, arg2 string, arg3 servers.UpdateOptsBuilder) (*servers.Server, error) {
	fake.updateServerMutex.Lock()
	ret, specificReturn := fake.updateServerReturnsOnCall[len(fake.updateServerArgsForCall)]
	fake.updateServerArgsForCall = append(fake.updateServerArgsForCall, struct {
		arg1 utils.ServiceClient
		arg2 string
		arg3 servers.UpdateOptsBuilder
	}{arg1, arg2, arg3})
	stub := fake.UpdateServerStub
	fakeReturns := fake.updateServerReturns
	fake.recordInvocation("UpdateServer", []interface{}{arg1, arg2, arg3})
	fake.updateServerMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeComputeFacade) UpdateServerCallCount() int {
	fake.updateServerMutex.RLock()
	defer fake.updateServerMutex.RUnlock()
	return len(fake.updateServerArgsForCall)
}

func (fake *FakeComputeFacade) UpdateServerCalls(stub func(utils.ServiceClient, string, servers.UpdateOptsBuilder) (*servers.Server, error)) {
	fake.updateServerMutex.Lock()
	defer fake.updateServerMutex.Unlock()
	fake.UpdateServerStub = stub
}

func (fake *FakeComputeFacade) UpdateServerArgsForCall(i int) (utils.ServiceClient, string, servers.UpdateOptsBuilder) {
	fake.updateServerMutex.RLock()
	defer fake.updateServerMutex.RUnlock()
	argsForCall := fake.updateServerArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeComputeFacade) UpdateServerReturns(result1 *servers.Server, result2 error) {
	fake.updateServerMutex.Lock()
	defer fake.updateServerMutex.Unlock()
	fake.UpdateServerStub = nil
	fake.updateServerReturns = struct {
		result1 *servers.Server
		result2 error
	}{result1, result2}
}

func (fake *FakeComputeFacade) UpdateServerReturnsOnCall(i int, result1 *servers.Server, result2 error) {
	fake.updateServerMutex.Lock()
	defer fake.updateServerMutex.Unlock()
	fake.UpdateServerStub = nil
	if fake.updateServerReturnsOnCall == nil {
		fake.updateServerReturnsOnCall = make(map[int]struct {
			result1 *servers.Server
			result2 error
		})
	}
	fake.updateServerReturnsOnCall[i] = struct {
		result1 *servers.Server
		result2 error
	}{result1, result2}
}

func (fake *FakeComputeFacade) UpdateServerMetadata(arg1 utils.ServiceClient, arg2 string, arg3 servers.UpdateMetadataOptsBuilder) (map[string]string, error) {
	fake.updateServerMetadataMutex.Lock()
	ret, specificReturn := fake.updateServerMetadataReturnsOnCall[len(fake.updateServerMetadataArgsForCall)]
	fake.updateServerMetadataArgsForCall = append(fake.updateServerMetadataArgsForCall, struct {
		arg1 utils.ServiceClient
		arg2 string
		arg3 servers.UpdateMetadataOptsBuilder
	}{arg1, arg2, arg3})
	stub := fake.UpdateServerMetadataStub
	fakeReturns := fake.updateServerMetadataReturns
	fake.recordInvocation("UpdateServerMetadata", []interface{}{arg1, arg2, arg3})
	fake.updateServerMetadataMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeComputeFacade) UpdateServerMetadataCallCount() int {
	fake.updateServerMetadataMutex.RLock()
	defer fake.updateServerMetadataMutex.RUnlock()
	return len(fake.updateServerMetadataArgsForCall)
}

func (fake *FakeComputeFacade) UpdateServerMetadataCalls(stub func(utils.ServiceClient, string, servers.UpdateMetadataOptsBuilder) (map[string]string, error)) {
	fake.updateServerMetadataMutex.Lock()
	defer fake.updateServerMetadataMutex.Unlock()
	fake.UpdateServerMetadataStub = stub
}

func (fake *FakeComputeFacade) UpdateServerMetadataArgsForCall(i int) (utils.ServiceClient, string, servers.UpdateMetadataOptsBuilder) {
	fake.updateServerMetadataMutex.RLock()
	defer fake.updateServerMetadataMutex.RUnlock()
	argsForCall := fake.updateServerMetadataArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeComputeFacade) UpdateServerMetadataReturns(result1 map[string]string, result2 error) {
	fake.updateServerMetadataMutex.Lock()
	defer fake.updateServerMetadataMutex.Unlock()
	fake.UpdateServerMetadataStub = nil
	fake.updateServerMetadataReturns = struct {
		result1 map[string]string
		result2 error
	}{result1, result2}
}

func (fake *FakeComputeFacade) UpdateServerMetadataReturnsOnCall(i int, result1 map[string]string, result2 error) {
	fake.updateServerMetadataMutex.Lock()
	defer fake.updateServerMetadataMutex.Unlock()
	fake.UpdateServerMetadataStub = nil
	if fake.updateServerMetadataReturnsOnCall == nil {
		fake.updateServerMetadataReturnsOnCall = make(map[int]struct {
			result1 map[string]string
			result2 error
		})
	}
	fake.updateServerMetadataReturnsOnCall[i] = struct {
		result1 map[string]string
		result2 error
	}{result1, result2}
}

func (fake *FakeComputeFacade) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.attachVolumeMutex.RLock()
	defer fake.attachVolumeMutex.RUnlock()
	fake.createServerMutex.RLock()
	defer fake.createServerMutex.RUnlock()
	fake.deleteServerMutex.RLock()
	defer fake.deleteServerMutex.RUnlock()
	fake.deleteServerMetaDataMutex.RLock()
	defer fake.deleteServerMetaDataMutex.RUnlock()
	fake.detachVolumeMutex.RLock()
	defer fake.detachVolumeMutex.RUnlock()
	fake.extractFlavorsMutex.RLock()
	defer fake.extractFlavorsMutex.RUnlock()
	fake.getOSKeyPairMutex.RLock()
	defer fake.getOSKeyPairMutex.RUnlock()
	fake.getServerMutex.RLock()
	defer fake.getServerMutex.RUnlock()
	fake.getServerMetadataMutex.RLock()
	defer fake.getServerMetadataMutex.RUnlock()
	fake.getServerWithAZMutex.RLock()
	defer fake.getServerWithAZMutex.RUnlock()
	fake.listFlavorsMutex.RLock()
	defer fake.listFlavorsMutex.RUnlock()
	fake.listVolumeAttachmentsMutex.RLock()
	defer fake.listVolumeAttachmentsMutex.RUnlock()
	fake.rebootServerMutex.RLock()
	defer fake.rebootServerMutex.RUnlock()
	fake.updateServerMutex.RLock()
	defer fake.updateServerMutex.RUnlock()
	fake.updateServerMetadataMutex.RLock()
	defer fake.updateServerMetadataMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeComputeFacade) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ compute.ComputeFacade = new(FakeComputeFacade)
