// Code generated by counterfeiter. DO NOT EDIT.
package computefakes

import (
	"sync"

	"github.com/cloudfoundry/bosh-cpi-go/apiv1"
	"github.com/cloudfoundry/bosh-openstack-cpi-release/src/openstack_cpi_golang/cpi/compute"
	"github.com/cloudfoundry/bosh-openstack-cpi-release/src/openstack_cpi_golang/cpi/config"
	"github.com/cloudfoundry/bosh-openstack-cpi-release/src/openstack_cpi_golang/cpi/properties"
	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/volumeattach"
	"github.com/gophercloud/gophercloud/openstack/compute/v2/flavors"
	"github.com/gophercloud/gophercloud/openstack/compute/v2/servers"
)

type FakeComputeService struct {
	AttachVolumeStub        func(string, string, string) (*volumeattach.VolumeAttachment, error)
	attachVolumeMutex       sync.RWMutex
	attachVolumeArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	attachVolumeReturns struct {
		result1 *volumeattach.VolumeAttachment
		result2 error
	}
	attachVolumeReturnsOnCall map[int]struct {
		result1 *volumeattach.VolumeAttachment
		result2 error
	}
	CreateServerStub        func(apiv1.StemcellCID, properties.CreateVM, properties.NetworkConfig, apiv1.AgentID, apiv1.VMEnv, config.CpiConfig) (*servers.Server, error)
	createServerMutex       sync.RWMutex
	createServerArgsForCall []struct {
		arg1 apiv1.StemcellCID
		arg2 properties.CreateVM
		arg3 properties.NetworkConfig
		arg4 apiv1.AgentID
		arg5 apiv1.VMEnv
		arg6 config.CpiConfig
	}
	createServerReturns struct {
		result1 *servers.Server
		result2 error
	}
	createServerReturnsOnCall map[int]struct {
		result1 *servers.Server
		result2 error
	}
	DeleteServerStub        func(string, config.CpiConfig) error
	deleteServerMutex       sync.RWMutex
	deleteServerArgsForCall []struct {
		arg1 string
		arg2 config.CpiConfig
	}
	deleteServerReturns struct {
		result1 error
	}
	deleteServerReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteServerMetaDataStub        func(string, map[string]string, properties.ServerMetadata) error
	deleteServerMetaDataMutex       sync.RWMutex
	deleteServerMetaDataArgsForCall []struct {
		arg1 string
		arg2 map[string]string
		arg3 properties.ServerMetadata
	}
	deleteServerMetaDataReturns struct {
		result1 error
	}
	deleteServerMetaDataReturnsOnCall map[int]struct {
		result1 error
	}
	DetachVolumeStub        func(string, string) error
	detachVolumeMutex       sync.RWMutex
	detachVolumeArgsForCall []struct {
		arg1 string
		arg2 string
	}
	detachVolumeReturns struct {
		result1 error
	}
	detachVolumeReturnsOnCall map[int]struct {
		result1 error
	}
	GetFlavorByIdStub        func(string) (flavors.Flavor, error)
	getFlavorByIdMutex       sync.RWMutex
	getFlavorByIdArgsForCall []struct {
		arg1 string
	}
	getFlavorByIdReturns struct {
		result1 flavors.Flavor
		result2 error
	}
	getFlavorByIdReturnsOnCall map[int]struct {
		result1 flavors.Flavor
		result2 error
	}
	GetMatchingFlavorStub        func(apiv1.VMResources, bool) (flavors.Flavor, error)
	getMatchingFlavorMutex       sync.RWMutex
	getMatchingFlavorArgsForCall []struct {
		arg1 apiv1.VMResources
		arg2 bool
	}
	getMatchingFlavorReturns struct {
		result1 flavors.Flavor
		result2 error
	}
	getMatchingFlavorReturnsOnCall map[int]struct {
		result1 flavors.Flavor
		result2 error
	}
	GetMetadataStub        func(string) (map[string]string, error)
	getMetadataMutex       sync.RWMutex
	getMetadataArgsForCall []struct {
		arg1 string
	}
	getMetadataReturns struct {
		result1 map[string]string
		result2 error
	}
	getMetadataReturnsOnCall map[int]struct {
		result1 map[string]string
		result2 error
	}
	GetServerStub        func(string) (*servers.Server, error)
	getServerMutex       sync.RWMutex
	getServerArgsForCall []struct {
		arg1 string
	}
	getServerReturns struct {
		result1 *servers.Server
		result2 error
	}
	getServerReturnsOnCall map[int]struct {
		result1 *servers.Server
		result2 error
	}
	GetServerAZStub        func(string) (string, error)
	getServerAZMutex       sync.RWMutex
	getServerAZArgsForCall []struct {
		arg1 string
	}
	getServerAZReturns struct {
		result1 string
		result2 error
	}
	getServerAZReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	ListVolumeAttachmentsStub        func(string) ([]volumeattach.VolumeAttachment, error)
	listVolumeAttachmentsMutex       sync.RWMutex
	listVolumeAttachmentsArgsForCall []struct {
		arg1 string
	}
	listVolumeAttachmentsReturns struct {
		result1 []volumeattach.VolumeAttachment
		result2 error
	}
	listVolumeAttachmentsReturnsOnCall map[int]struct {
		result1 []volumeattach.VolumeAttachment
		result2 error
	}
	RebootServerStub        func(string, config.CpiConfig) error
	rebootServerMutex       sync.RWMutex
	rebootServerArgsForCall []struct {
		arg1 string
		arg2 config.CpiConfig
	}
	rebootServerReturns struct {
		result1 error
	}
	rebootServerReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateServerStub        func(string, string) (*servers.Server, error)
	updateServerMutex       sync.RWMutex
	updateServerArgsForCall []struct {
		arg1 string
		arg2 string
	}
	updateServerReturns struct {
		result1 *servers.Server
		result2 error
	}
	updateServerReturnsOnCall map[int]struct {
		result1 *servers.Server
		result2 error
	}
	UpdateServerMetadataStub        func(string, properties.ServerMetadata) error
	updateServerMetadataMutex       sync.RWMutex
	updateServerMetadataArgsForCall []struct {
		arg1 string
		arg2 properties.ServerMetadata
	}
	updateServerMetadataReturns struct {
		result1 error
	}
	updateServerMetadataReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeComputeService) AttachVolume(arg1 string, arg2 string, arg3 string) (*volumeattach.VolumeAttachment, error) {
	fake.attachVolumeMutex.Lock()
	ret, specificReturn := fake.attachVolumeReturnsOnCall[len(fake.attachVolumeArgsForCall)]
	fake.attachVolumeArgsForCall = append(fake.attachVolumeArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.AttachVolumeStub
	fakeReturns := fake.attachVolumeReturns
	fake.recordInvocation("AttachVolume", []interface{}{arg1, arg2, arg3})
	fake.attachVolumeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeComputeService) AttachVolumeCallCount() int {
	fake.attachVolumeMutex.RLock()
	defer fake.attachVolumeMutex.RUnlock()
	return len(fake.attachVolumeArgsForCall)
}

func (fake *FakeComputeService) AttachVolumeCalls(stub func(string, string, string) (*volumeattach.VolumeAttachment, error)) {
	fake.attachVolumeMutex.Lock()
	defer fake.attachVolumeMutex.Unlock()
	fake.AttachVolumeStub = stub
}

func (fake *FakeComputeService) AttachVolumeArgsForCall(i int) (string, string, string) {
	fake.attachVolumeMutex.RLock()
	defer fake.attachVolumeMutex.RUnlock()
	argsForCall := fake.attachVolumeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeComputeService) AttachVolumeReturns(result1 *volumeattach.VolumeAttachment, result2 error) {
	fake.attachVolumeMutex.Lock()
	defer fake.attachVolumeMutex.Unlock()
	fake.AttachVolumeStub = nil
	fake.attachVolumeReturns = struct {
		result1 *volumeattach.VolumeAttachment
		result2 error
	}{result1, result2}
}

func (fake *FakeComputeService) AttachVolumeReturnsOnCall(i int, result1 *volumeattach.VolumeAttachment, result2 error) {
	fake.attachVolumeMutex.Lock()
	defer fake.attachVolumeMutex.Unlock()
	fake.AttachVolumeStub = nil
	if fake.attachVolumeReturnsOnCall == nil {
		fake.attachVolumeReturnsOnCall = make(map[int]struct {
			result1 *volumeattach.VolumeAttachment
			result2 error
		})
	}
	fake.attachVolumeReturnsOnCall[i] = struct {
		result1 *volumeattach.VolumeAttachment
		result2 error
	}{result1, result2}
}

func (fake *FakeComputeService) CreateServer(arg1 apiv1.StemcellCID, arg2 properties.CreateVM, arg3 properties.NetworkConfig, arg4 apiv1.AgentID, arg5 apiv1.VMEnv, arg6 config.CpiConfig) (*servers.Server, error) {
	fake.createServerMutex.Lock()
	ret, specificReturn := fake.createServerReturnsOnCall[len(fake.createServerArgsForCall)]
	fake.createServerArgsForCall = append(fake.createServerArgsForCall, struct {
		arg1 apiv1.StemcellCID
		arg2 properties.CreateVM
		arg3 properties.NetworkConfig
		arg4 apiv1.AgentID
		arg5 apiv1.VMEnv
		arg6 config.CpiConfig
	}{arg1, arg2, arg3, arg4, arg5, arg6})
	stub := fake.CreateServerStub
	fakeReturns := fake.createServerReturns
	fake.recordInvocation("CreateServer", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6})
	fake.createServerMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeComputeService) CreateServerCallCount() int {
	fake.createServerMutex.RLock()
	defer fake.createServerMutex.RUnlock()
	return len(fake.createServerArgsForCall)
}

func (fake *FakeComputeService) CreateServerCalls(stub func(apiv1.StemcellCID, properties.CreateVM, properties.NetworkConfig, apiv1.AgentID, apiv1.VMEnv, config.CpiConfig) (*servers.Server, error)) {
	fake.createServerMutex.Lock()
	defer fake.createServerMutex.Unlock()
	fake.CreateServerStub = stub
}

func (fake *FakeComputeService) CreateServerArgsForCall(i int) (apiv1.StemcellCID, properties.CreateVM, properties.NetworkConfig, apiv1.AgentID, apiv1.VMEnv, config.CpiConfig) {
	fake.createServerMutex.RLock()
	defer fake.createServerMutex.RUnlock()
	argsForCall := fake.createServerArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6
}

func (fake *FakeComputeService) CreateServerReturns(result1 *servers.Server, result2 error) {
	fake.createServerMutex.Lock()
	defer fake.createServerMutex.Unlock()
	fake.CreateServerStub = nil
	fake.createServerReturns = struct {
		result1 *servers.Server
		result2 error
	}{result1, result2}
}

func (fake *FakeComputeService) CreateServerReturnsOnCall(i int, result1 *servers.Server, result2 error) {
	fake.createServerMutex.Lock()
	defer fake.createServerMutex.Unlock()
	fake.CreateServerStub = nil
	if fake.createServerReturnsOnCall == nil {
		fake.createServerReturnsOnCall = make(map[int]struct {
			result1 *servers.Server
			result2 error
		})
	}
	fake.createServerReturnsOnCall[i] = struct {
		result1 *servers.Server
		result2 error
	}{result1, result2}
}

func (fake *FakeComputeService) DeleteServer(arg1 string, arg2 config.CpiConfig) error {
	fake.deleteServerMutex.Lock()
	ret, specificReturn := fake.deleteServerReturnsOnCall[len(fake.deleteServerArgsForCall)]
	fake.deleteServerArgsForCall = append(fake.deleteServerArgsForCall, struct {
		arg1 string
		arg2 config.CpiConfig
	}{arg1, arg2})
	stub := fake.DeleteServerStub
	fakeReturns := fake.deleteServerReturns
	fake.recordInvocation("DeleteServer", []interface{}{arg1, arg2})
	fake.deleteServerMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeComputeService) DeleteServerCallCount() int {
	fake.deleteServerMutex.RLock()
	defer fake.deleteServerMutex.RUnlock()
	return len(fake.deleteServerArgsForCall)
}

func (fake *FakeComputeService) DeleteServerCalls(stub func(string, config.CpiConfig) error) {
	fake.deleteServerMutex.Lock()
	defer fake.deleteServerMutex.Unlock()
	fake.DeleteServerStub = stub
}

func (fake *FakeComputeService) DeleteServerArgsForCall(i int) (string, config.CpiConfig) {
	fake.deleteServerMutex.RLock()
	defer fake.deleteServerMutex.RUnlock()
	argsForCall := fake.deleteServerArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeComputeService) DeleteServerReturns(result1 error) {
	fake.deleteServerMutex.Lock()
	defer fake.deleteServerMutex.Unlock()
	fake.DeleteServerStub = nil
	fake.deleteServerReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeComputeService) DeleteServerReturnsOnCall(i int, result1 error) {
	fake.deleteServerMutex.Lock()
	defer fake.deleteServerMutex.Unlock()
	fake.DeleteServerStub = nil
	if fake.deleteServerReturnsOnCall == nil {
		fake.deleteServerReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteServerReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeComputeService) DeleteServerMetaData(arg1 string, arg2 map[string]string, arg3 properties.ServerMetadata) error {
	fake.deleteServerMetaDataMutex.Lock()
	ret, specificReturn := fake.deleteServerMetaDataReturnsOnCall[len(fake.deleteServerMetaDataArgsForCall)]
	fake.deleteServerMetaDataArgsForCall = append(fake.deleteServerMetaDataArgsForCall, struct {
		arg1 string
		arg2 map[string]string
		arg3 properties.ServerMetadata
	}{arg1, arg2, arg3})
	stub := fake.DeleteServerMetaDataStub
	fakeReturns := fake.deleteServerMetaDataReturns
	fake.recordInvocation("DeleteServerMetaData", []interface{}{arg1, arg2, arg3})
	fake.deleteServerMetaDataMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeComputeService) DeleteServerMetaDataCallCount() int {
	fake.deleteServerMetaDataMutex.RLock()
	defer fake.deleteServerMetaDataMutex.RUnlock()
	return len(fake.deleteServerMetaDataArgsForCall)
}

func (fake *FakeComputeService) DeleteServerMetaDataCalls(stub func(string, map[string]string, properties.ServerMetadata) error) {
	fake.deleteServerMetaDataMutex.Lock()
	defer fake.deleteServerMetaDataMutex.Unlock()
	fake.DeleteServerMetaDataStub = stub
}

func (fake *FakeComputeService) DeleteServerMetaDataArgsForCall(i int) (string, map[string]string, properties.ServerMetadata) {
	fake.deleteServerMetaDataMutex.RLock()
	defer fake.deleteServerMetaDataMutex.RUnlock()
	argsForCall := fake.deleteServerMetaDataArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeComputeService) DeleteServerMetaDataReturns(result1 error) {
	fake.deleteServerMetaDataMutex.Lock()
	defer fake.deleteServerMetaDataMutex.Unlock()
	fake.DeleteServerMetaDataStub = nil
	fake.deleteServerMetaDataReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeComputeService) DeleteServerMetaDataReturnsOnCall(i int, result1 error) {
	fake.deleteServerMetaDataMutex.Lock()
	defer fake.deleteServerMetaDataMutex.Unlock()
	fake.DeleteServerMetaDataStub = nil
	if fake.deleteServerMetaDataReturnsOnCall == nil {
		fake.deleteServerMetaDataReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteServerMetaDataReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeComputeService) DetachVolume(arg1 string, arg2 string) error {
	fake.detachVolumeMutex.Lock()
	ret, specificReturn := fake.detachVolumeReturnsOnCall[len(fake.detachVolumeArgsForCall)]
	fake.detachVolumeArgsForCall = append(fake.detachVolumeArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.DetachVolumeStub
	fakeReturns := fake.detachVolumeReturns
	fake.recordInvocation("DetachVolume", []interface{}{arg1, arg2})
	fake.detachVolumeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeComputeService) DetachVolumeCallCount() int {
	fake.detachVolumeMutex.RLock()
	defer fake.detachVolumeMutex.RUnlock()
	return len(fake.detachVolumeArgsForCall)
}

func (fake *FakeComputeService) DetachVolumeCalls(stub func(string, string) error) {
	fake.detachVolumeMutex.Lock()
	defer fake.detachVolumeMutex.Unlock()
	fake.DetachVolumeStub = stub
}

func (fake *FakeComputeService) DetachVolumeArgsForCall(i int) (string, string) {
	fake.detachVolumeMutex.RLock()
	defer fake.detachVolumeMutex.RUnlock()
	argsForCall := fake.detachVolumeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeComputeService) DetachVolumeReturns(result1 error) {
	fake.detachVolumeMutex.Lock()
	defer fake.detachVolumeMutex.Unlock()
	fake.DetachVolumeStub = nil
	fake.detachVolumeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeComputeService) DetachVolumeReturnsOnCall(i int, result1 error) {
	fake.detachVolumeMutex.Lock()
	defer fake.detachVolumeMutex.Unlock()
	fake.DetachVolumeStub = nil
	if fake.detachVolumeReturnsOnCall == nil {
		fake.detachVolumeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.detachVolumeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeComputeService) GetFlavorById(arg1 string) (flavors.Flavor, error) {
	fake.getFlavorByIdMutex.Lock()
	ret, specificReturn := fake.getFlavorByIdReturnsOnCall[len(fake.getFlavorByIdArgsForCall)]
	fake.getFlavorByIdArgsForCall = append(fake.getFlavorByIdArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetFlavorByIdStub
	fakeReturns := fake.getFlavorByIdReturns
	fake.recordInvocation("GetFlavorById", []interface{}{arg1})
	fake.getFlavorByIdMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeComputeService) GetFlavorByIdCallCount() int {
	fake.getFlavorByIdMutex.RLock()
	defer fake.getFlavorByIdMutex.RUnlock()
	return len(fake.getFlavorByIdArgsForCall)
}

func (fake *FakeComputeService) GetFlavorByIdCalls(stub func(string) (flavors.Flavor, error)) {
	fake.getFlavorByIdMutex.Lock()
	defer fake.getFlavorByIdMutex.Unlock()
	fake.GetFlavorByIdStub = stub
}

func (fake *FakeComputeService) GetFlavorByIdArgsForCall(i int) string {
	fake.getFlavorByIdMutex.RLock()
	defer fake.getFlavorByIdMutex.RUnlock()
	argsForCall := fake.getFlavorByIdArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeComputeService) GetFlavorByIdReturns(result1 flavors.Flavor, result2 error) {
	fake.getFlavorByIdMutex.Lock()
	defer fake.getFlavorByIdMutex.Unlock()
	fake.GetFlavorByIdStub = nil
	fake.getFlavorByIdReturns = struct {
		result1 flavors.Flavor
		result2 error
	}{result1, result2}
}

func (fake *FakeComputeService) GetFlavorByIdReturnsOnCall(i int, result1 flavors.Flavor, result2 error) {
	fake.getFlavorByIdMutex.Lock()
	defer fake.getFlavorByIdMutex.Unlock()
	fake.GetFlavorByIdStub = nil
	if fake.getFlavorByIdReturnsOnCall == nil {
		fake.getFlavorByIdReturnsOnCall = make(map[int]struct {
			result1 flavors.Flavor
			result2 error
		})
	}
	fake.getFlavorByIdReturnsOnCall[i] = struct {
		result1 flavors.Flavor
		result2 error
	}{result1, result2}
}

func (fake *FakeComputeService) GetMatchingFlavor(arg1 apiv1.VMResources, arg2 bool) (flavors.Flavor, error) {
	fake.getMatchingFlavorMutex.Lock()
	ret, specificReturn := fake.getMatchingFlavorReturnsOnCall[len(fake.getMatchingFlavorArgsForCall)]
	fake.getMatchingFlavorArgsForCall = append(fake.getMatchingFlavorArgsForCall, struct {
		arg1 apiv1.VMResources
		arg2 bool
	}{arg1, arg2})
	stub := fake.GetMatchingFlavorStub
	fakeReturns := fake.getMatchingFlavorReturns
	fake.recordInvocation("GetMatchingFlavor", []interface{}{arg1, arg2})
	fake.getMatchingFlavorMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeComputeService) GetMatchingFlavorCallCount() int {
	fake.getMatchingFlavorMutex.RLock()
	defer fake.getMatchingFlavorMutex.RUnlock()
	return len(fake.getMatchingFlavorArgsForCall)
}

func (fake *FakeComputeService) GetMatchingFlavorCalls(stub func(apiv1.VMResources, bool) (flavors.Flavor, error)) {
	fake.getMatchingFlavorMutex.Lock()
	defer fake.getMatchingFlavorMutex.Unlock()
	fake.GetMatchingFlavorStub = stub
}

func (fake *FakeComputeService) GetMatchingFlavorArgsForCall(i int) (apiv1.VMResources, bool) {
	fake.getMatchingFlavorMutex.RLock()
	defer fake.getMatchingFlavorMutex.RUnlock()
	argsForCall := fake.getMatchingFlavorArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeComputeService) GetMatchingFlavorReturns(result1 flavors.Flavor, result2 error) {
	fake.getMatchingFlavorMutex.Lock()
	defer fake.getMatchingFlavorMutex.Unlock()
	fake.GetMatchingFlavorStub = nil
	fake.getMatchingFlavorReturns = struct {
		result1 flavors.Flavor
		result2 error
	}{result1, result2}
}

func (fake *FakeComputeService) GetMatchingFlavorReturnsOnCall(i int, result1 flavors.Flavor, result2 error) {
	fake.getMatchingFlavorMutex.Lock()
	defer fake.getMatchingFlavorMutex.Unlock()
	fake.GetMatchingFlavorStub = nil
	if fake.getMatchingFlavorReturnsOnCall == nil {
		fake.getMatchingFlavorReturnsOnCall = make(map[int]struct {
			result1 flavors.Flavor
			result2 error
		})
	}
	fake.getMatchingFlavorReturnsOnCall[i] = struct {
		result1 flavors.Flavor
		result2 error
	}{result1, result2}
}

func (fake *FakeComputeService) GetMetadata(arg1 string) (map[string]string, error) {
	fake.getMetadataMutex.Lock()
	ret, specificReturn := fake.getMetadataReturnsOnCall[len(fake.getMetadataArgsForCall)]
	fake.getMetadataArgsForCall = append(fake.getMetadataArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetMetadataStub
	fakeReturns := fake.getMetadataReturns
	fake.recordInvocation("GetMetadata", []interface{}{arg1})
	fake.getMetadataMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeComputeService) GetMetadataCallCount() int {
	fake.getMetadataMutex.RLock()
	defer fake.getMetadataMutex.RUnlock()
	return len(fake.getMetadataArgsForCall)
}

func (fake *FakeComputeService) GetMetadataCalls(stub func(string) (map[string]string, error)) {
	fake.getMetadataMutex.Lock()
	defer fake.getMetadataMutex.Unlock()
	fake.GetMetadataStub = stub
}

func (fake *FakeComputeService) GetMetadataArgsForCall(i int) string {
	fake.getMetadataMutex.RLock()
	defer fake.getMetadataMutex.RUnlock()
	argsForCall := fake.getMetadataArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeComputeService) GetMetadataReturns(result1 map[string]string, result2 error) {
	fake.getMetadataMutex.Lock()
	defer fake.getMetadataMutex.Unlock()
	fake.GetMetadataStub = nil
	fake.getMetadataReturns = struct {
		result1 map[string]string
		result2 error
	}{result1, result2}
}

func (fake *FakeComputeService) GetMetadataReturnsOnCall(i int, result1 map[string]string, result2 error) {
	fake.getMetadataMutex.Lock()
	defer fake.getMetadataMutex.Unlock()
	fake.GetMetadataStub = nil
	if fake.getMetadataReturnsOnCall == nil {
		fake.getMetadataReturnsOnCall = make(map[int]struct {
			result1 map[string]string
			result2 error
		})
	}
	fake.getMetadataReturnsOnCall[i] = struct {
		result1 map[string]string
		result2 error
	}{result1, result2}
}

func (fake *FakeComputeService) GetServer(arg1 string) (*servers.Server, error) {
	fake.getServerMutex.Lock()
	ret, specificReturn := fake.getServerReturnsOnCall[len(fake.getServerArgsForCall)]
	fake.getServerArgsForCall = append(fake.getServerArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetServerStub
	fakeReturns := fake.getServerReturns
	fake.recordInvocation("GetServer", []interface{}{arg1})
	fake.getServerMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeComputeService) GetServerCallCount() int {
	fake.getServerMutex.RLock()
	defer fake.getServerMutex.RUnlock()
	return len(fake.getServerArgsForCall)
}

func (fake *FakeComputeService) GetServerCalls(stub func(string) (*servers.Server, error)) {
	fake.getServerMutex.Lock()
	defer fake.getServerMutex.Unlock()
	fake.GetServerStub = stub
}

func (fake *FakeComputeService) GetServerArgsForCall(i int) string {
	fake.getServerMutex.RLock()
	defer fake.getServerMutex.RUnlock()
	argsForCall := fake.getServerArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeComputeService) GetServerReturns(result1 *servers.Server, result2 error) {
	fake.getServerMutex.Lock()
	defer fake.getServerMutex.Unlock()
	fake.GetServerStub = nil
	fake.getServerReturns = struct {
		result1 *servers.Server
		result2 error
	}{result1, result2}
}

func (fake *FakeComputeService) GetServerReturnsOnCall(i int, result1 *servers.Server, result2 error) {
	fake.getServerMutex.Lock()
	defer fake.getServerMutex.Unlock()
	fake.GetServerStub = nil
	if fake.getServerReturnsOnCall == nil {
		fake.getServerReturnsOnCall = make(map[int]struct {
			result1 *servers.Server
			result2 error
		})
	}
	fake.getServerReturnsOnCall[i] = struct {
		result1 *servers.Server
		result2 error
	}{result1, result2}
}

func (fake *FakeComputeService) GetServerAZ(arg1 string) (string, error) {
	fake.getServerAZMutex.Lock()
	ret, specificReturn := fake.getServerAZReturnsOnCall[len(fake.getServerAZArgsForCall)]
	fake.getServerAZArgsForCall = append(fake.getServerAZArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetServerAZStub
	fakeReturns := fake.getServerAZReturns
	fake.recordInvocation("GetServerAZ", []interface{}{arg1})
	fake.getServerAZMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeComputeService) GetServerAZCallCount() int {
	fake.getServerAZMutex.RLock()
	defer fake.getServerAZMutex.RUnlock()
	return len(fake.getServerAZArgsForCall)
}

func (fake *FakeComputeService) GetServerAZCalls(stub func(string) (string, error)) {
	fake.getServerAZMutex.Lock()
	defer fake.getServerAZMutex.Unlock()
	fake.GetServerAZStub = stub
}

func (fake *FakeComputeService) GetServerAZArgsForCall(i int) string {
	fake.getServerAZMutex.RLock()
	defer fake.getServerAZMutex.RUnlock()
	argsForCall := fake.getServerAZArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeComputeService) GetServerAZReturns(result1 string, result2 error) {
	fake.getServerAZMutex.Lock()
	defer fake.getServerAZMutex.Unlock()
	fake.GetServerAZStub = nil
	fake.getServerAZReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeComputeService) GetServerAZReturnsOnCall(i int, result1 string, result2 error) {
	fake.getServerAZMutex.Lock()
	defer fake.getServerAZMutex.Unlock()
	fake.GetServerAZStub = nil
	if fake.getServerAZReturnsOnCall == nil {
		fake.getServerAZReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getServerAZReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeComputeService) ListVolumeAttachments(arg1 string) ([]volumeattach.VolumeAttachment, error) {
	fake.listVolumeAttachmentsMutex.Lock()
	ret, specificReturn := fake.listVolumeAttachmentsReturnsOnCall[len(fake.listVolumeAttachmentsArgsForCall)]
	fake.listVolumeAttachmentsArgsForCall = append(fake.listVolumeAttachmentsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ListVolumeAttachmentsStub
	fakeReturns := fake.listVolumeAttachmentsReturns
	fake.recordInvocation("ListVolumeAttachments", []interface{}{arg1})
	fake.listVolumeAttachmentsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeComputeService) ListVolumeAttachmentsCallCount() int {
	fake.listVolumeAttachmentsMutex.RLock()
	defer fake.listVolumeAttachmentsMutex.RUnlock()
	return len(fake.listVolumeAttachmentsArgsForCall)
}

func (fake *FakeComputeService) ListVolumeAttachmentsCalls(stub func(string) ([]volumeattach.VolumeAttachment, error)) {
	fake.listVolumeAttachmentsMutex.Lock()
	defer fake.listVolumeAttachmentsMutex.Unlock()
	fake.ListVolumeAttachmentsStub = stub
}

func (fake *FakeComputeService) ListVolumeAttachmentsArgsForCall(i int) string {
	fake.listVolumeAttachmentsMutex.RLock()
	defer fake.listVolumeAttachmentsMutex.RUnlock()
	argsForCall := fake.listVolumeAttachmentsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeComputeService) ListVolumeAttachmentsReturns(result1 []volumeattach.VolumeAttachment, result2 error) {
	fake.listVolumeAttachmentsMutex.Lock()
	defer fake.listVolumeAttachmentsMutex.Unlock()
	fake.ListVolumeAttachmentsStub = nil
	fake.listVolumeAttachmentsReturns = struct {
		result1 []volumeattach.VolumeAttachment
		result2 error
	}{result1, result2}
}

func (fake *FakeComputeService) ListVolumeAttachmentsReturnsOnCall(i int, result1 []volumeattach.VolumeAttachment, result2 error) {
	fake.listVolumeAttachmentsMutex.Lock()
	defer fake.listVolumeAttachmentsMutex.Unlock()
	fake.ListVolumeAttachmentsStub = nil
	if fake.listVolumeAttachmentsReturnsOnCall == nil {
		fake.listVolumeAttachmentsReturnsOnCall = make(map[int]struct {
			result1 []volumeattach.VolumeAttachment
			result2 error
		})
	}
	fake.listVolumeAttachmentsReturnsOnCall[i] = struct {
		result1 []volumeattach.VolumeAttachment
		result2 error
	}{result1, result2}
}

func (fake *FakeComputeService) RebootServer(arg1 string, arg2 config.CpiConfig) error {
	fake.rebootServerMutex.Lock()
	ret, specificReturn := fake.rebootServerReturnsOnCall[len(fake.rebootServerArgsForCall)]
	fake.rebootServerArgsForCall = append(fake.rebootServerArgsForCall, struct {
		arg1 string
		arg2 config.CpiConfig
	}{arg1, arg2})
	stub := fake.RebootServerStub
	fakeReturns := fake.rebootServerReturns
	fake.recordInvocation("RebootServer", []interface{}{arg1, arg2})
	fake.rebootServerMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeComputeService) RebootServerCallCount() int {
	fake.rebootServerMutex.RLock()
	defer fake.rebootServerMutex.RUnlock()
	return len(fake.rebootServerArgsForCall)
}

func (fake *FakeComputeService) RebootServerCalls(stub func(string, config.CpiConfig) error) {
	fake.rebootServerMutex.Lock()
	defer fake.rebootServerMutex.Unlock()
	fake.RebootServerStub = stub
}

func (fake *FakeComputeService) RebootServerArgsForCall(i int) (string, config.CpiConfig) {
	fake.rebootServerMutex.RLock()
	defer fake.rebootServerMutex.RUnlock()
	argsForCall := fake.rebootServerArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeComputeService) RebootServerReturns(result1 error) {
	fake.rebootServerMutex.Lock()
	defer fake.rebootServerMutex.Unlock()
	fake.RebootServerStub = nil
	fake.rebootServerReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeComputeService) RebootServerReturnsOnCall(i int, result1 error) {
	fake.rebootServerMutex.Lock()
	defer fake.rebootServerMutex.Unlock()
	fake.RebootServerStub = nil
	if fake.rebootServerReturnsOnCall == nil {
		fake.rebootServerReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.rebootServerReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeComputeService) UpdateServer(arg1 string, arg2 string) (*servers.Server, error) {
	fake.updateServerMutex.Lock()
	ret, specificReturn := fake.updateServerReturnsOnCall[len(fake.updateServerArgsForCall)]
	fake.updateServerArgsForCall = append(fake.updateServerArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.UpdateServerStub
	fakeReturns := fake.updateServerReturns
	fake.recordInvocation("UpdateServer", []interface{}{arg1, arg2})
	fake.updateServerMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeComputeService) UpdateServerCallCount() int {
	fake.updateServerMutex.RLock()
	defer fake.updateServerMutex.RUnlock()
	return len(fake.updateServerArgsForCall)
}

func (fake *FakeComputeService) UpdateServerCalls(stub func(string, string) (*servers.Server, error)) {
	fake.updateServerMutex.Lock()
	defer fake.updateServerMutex.Unlock()
	fake.UpdateServerStub = stub
}

func (fake *FakeComputeService) UpdateServerArgsForCall(i int) (string, string) {
	fake.updateServerMutex.RLock()
	defer fake.updateServerMutex.RUnlock()
	argsForCall := fake.updateServerArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeComputeService) UpdateServerReturns(result1 *servers.Server, result2 error) {
	fake.updateServerMutex.Lock()
	defer fake.updateServerMutex.Unlock()
	fake.UpdateServerStub = nil
	fake.updateServerReturns = struct {
		result1 *servers.Server
		result2 error
	}{result1, result2}
}

func (fake *FakeComputeService) UpdateServerReturnsOnCall(i int, result1 *servers.Server, result2 error) {
	fake.updateServerMutex.Lock()
	defer fake.updateServerMutex.Unlock()
	fake.UpdateServerStub = nil
	if fake.updateServerReturnsOnCall == nil {
		fake.updateServerReturnsOnCall = make(map[int]struct {
			result1 *servers.Server
			result2 error
		})
	}
	fake.updateServerReturnsOnCall[i] = struct {
		result1 *servers.Server
		result2 error
	}{result1, result2}
}

func (fake *FakeComputeService) UpdateServerMetadata(arg1 string, arg2 properties.ServerMetadata) error {
	fake.updateServerMetadataMutex.Lock()
	ret, specificReturn := fake.updateServerMetadataReturnsOnCall[len(fake.updateServerMetadataArgsForCall)]
	fake.updateServerMetadataArgsForCall = append(fake.updateServerMetadataArgsForCall, struct {
		arg1 string
		arg2 properties.ServerMetadata
	}{arg1, arg2})
	stub := fake.UpdateServerMetadataStub
	fakeReturns := fake.updateServerMetadataReturns
	fake.recordInvocation("UpdateServerMetadata", []interface{}{arg1, arg2})
	fake.updateServerMetadataMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeComputeService) UpdateServerMetadataCallCount() int {
	fake.updateServerMetadataMutex.RLock()
	defer fake.updateServerMetadataMutex.RUnlock()
	return len(fake.updateServerMetadataArgsForCall)
}

func (fake *FakeComputeService) UpdateServerMetadataCalls(stub func(string, properties.ServerMetadata) error) {
	fake.updateServerMetadataMutex.Lock()
	defer fake.updateServerMetadataMutex.Unlock()
	fake.UpdateServerMetadataStub = stub
}

func (fake *FakeComputeService) UpdateServerMetadataArgsForCall(i int) (string, properties.ServerMetadata) {
	fake.updateServerMetadataMutex.RLock()
	defer fake.updateServerMetadataMutex.RUnlock()
	argsForCall := fake.updateServerMetadataArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeComputeService) UpdateServerMetadataReturns(result1 error) {
	fake.updateServerMetadataMutex.Lock()
	defer fake.updateServerMetadataMutex.Unlock()
	fake.UpdateServerMetadataStub = nil
	fake.updateServerMetadataReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeComputeService) UpdateServerMetadataReturnsOnCall(i int, result1 error) {
	fake.updateServerMetadataMutex.Lock()
	defer fake.updateServerMetadataMutex.Unlock()
	fake.UpdateServerMetadataStub = nil
	if fake.updateServerMetadataReturnsOnCall == nil {
		fake.updateServerMetadataReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateServerMetadataReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeComputeService) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.attachVolumeMutex.RLock()
	defer fake.attachVolumeMutex.RUnlock()
	fake.createServerMutex.RLock()
	defer fake.createServerMutex.RUnlock()
	fake.deleteServerMutex.RLock()
	defer fake.deleteServerMutex.RUnlock()
	fake.deleteServerMetaDataMutex.RLock()
	defer fake.deleteServerMetaDataMutex.RUnlock()
	fake.detachVolumeMutex.RLock()
	defer fake.detachVolumeMutex.RUnlock()
	fake.getFlavorByIdMutex.RLock()
	defer fake.getFlavorByIdMutex.RUnlock()
	fake.getMatchingFlavorMutex.RLock()
	defer fake.getMatchingFlavorMutex.RUnlock()
	fake.getMetadataMutex.RLock()
	defer fake.getMetadataMutex.RUnlock()
	fake.getServerMutex.RLock()
	defer fake.getServerMutex.RUnlock()
	fake.getServerAZMutex.RLock()
	defer fake.getServerAZMutex.RUnlock()
	fake.listVolumeAttachmentsMutex.RLock()
	defer fake.listVolumeAttachmentsMutex.RUnlock()
	fake.rebootServerMutex.RLock()
	defer fake.rebootServerMutex.RUnlock()
	fake.updateServerMutex.RLock()
	defer fake.updateServerMutex.RUnlock()
	fake.updateServerMetadataMutex.RLock()
	defer fake.updateServerMetadataMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeComputeService) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ compute.ComputeService = new(FakeComputeService)
