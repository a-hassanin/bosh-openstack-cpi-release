// Code generated by counterfeiter. DO NOT EDIT.
package networkfakes

import (
	"sync"

	"github.com/cloudfoundry/bosh-openstack-cpi-release/src/openstack_cpi_golang/cpi/network"
	"github.com/cloudfoundry/bosh-openstack-cpi-release/src/openstack_cpi_golang/cpi/utils"
	"github.com/gophercloud/gophercloud/openstack/networking/v2/extensions/layer3/floatingips"
	"github.com/gophercloud/gophercloud/openstack/networking/v2/extensions/security/groups"
	"github.com/gophercloud/gophercloud/openstack/networking/v2/ports"
	"github.com/gophercloud/gophercloud/openstack/networking/v2/subnets"
	"github.com/gophercloud/gophercloud/pagination"
)

type FakeNetworkingFacade struct {
	CreatePortStub        func(utils.ServiceClient, ports.CreateOpts) (*ports.Port, error)
	createPortMutex       sync.RWMutex
	createPortArgsForCall []struct {
		arg1 utils.ServiceClient
		arg2 ports.CreateOpts
	}
	createPortReturns struct {
		result1 *ports.Port
		result2 error
	}
	createPortReturnsOnCall map[int]struct {
		result1 *ports.Port
		result2 error
	}
	DeletePortStub        func(utils.RetryableServiceClient, string) error
	deletePortMutex       sync.RWMutex
	deletePortArgsForCall []struct {
		arg1 utils.RetryableServiceClient
		arg2 string
	}
	deletePortReturns struct {
		result1 error
	}
	deletePortReturnsOnCall map[int]struct {
		result1 error
	}
	ExtractFloatingIPsStub        func(pagination.Page) ([]floatingips.FloatingIP, error)
	extractFloatingIPsMutex       sync.RWMutex
	extractFloatingIPsArgsForCall []struct {
		arg1 pagination.Page
	}
	extractFloatingIPsReturns struct {
		result1 []floatingips.FloatingIP
		result2 error
	}
	extractFloatingIPsReturnsOnCall map[int]struct {
		result1 []floatingips.FloatingIP
		result2 error
	}
	ExtractPortsStub        func(pagination.Page) ([]ports.Port, error)
	extractPortsMutex       sync.RWMutex
	extractPortsArgsForCall []struct {
		arg1 pagination.Page
	}
	extractPortsReturns struct {
		result1 []ports.Port
		result2 error
	}
	extractPortsReturnsOnCall map[int]struct {
		result1 []ports.Port
		result2 error
	}
	ExtractSecurityGroupsStub        func(pagination.Page) ([]groups.SecGroup, error)
	extractSecurityGroupsMutex       sync.RWMutex
	extractSecurityGroupsArgsForCall []struct {
		arg1 pagination.Page
	}
	extractSecurityGroupsReturns struct {
		result1 []groups.SecGroup
		result2 error
	}
	extractSecurityGroupsReturnsOnCall map[int]struct {
		result1 []groups.SecGroup
		result2 error
	}
	ExtractSubnetsStub        func(pagination.Page) ([]subnets.Subnet, error)
	extractSubnetsMutex       sync.RWMutex
	extractSubnetsArgsForCall []struct {
		arg1 pagination.Page
	}
	extractSubnetsReturns struct {
		result1 []subnets.Subnet
		result2 error
	}
	extractSubnetsReturnsOnCall map[int]struct {
		result1 []subnets.Subnet
		result2 error
	}
	GetSecurityGroupsStub        func(utils.RetryableServiceClient, string) (*groups.SecGroup, error)
	getSecurityGroupsMutex       sync.RWMutex
	getSecurityGroupsArgsForCall []struct {
		arg1 utils.RetryableServiceClient
		arg2 string
	}
	getSecurityGroupsReturns struct {
		result1 *groups.SecGroup
		result2 error
	}
	getSecurityGroupsReturnsOnCall map[int]struct {
		result1 *groups.SecGroup
		result2 error
	}
	ListFloatingIpsStub        func(utils.RetryableServiceClient, floatingips.ListOpts) (pagination.Page, error)
	listFloatingIpsMutex       sync.RWMutex
	listFloatingIpsArgsForCall []struct {
		arg1 utils.RetryableServiceClient
		arg2 floatingips.ListOpts
	}
	listFloatingIpsReturns struct {
		result1 pagination.Page
		result2 error
	}
	listFloatingIpsReturnsOnCall map[int]struct {
		result1 pagination.Page
		result2 error
	}
	ListPortsStub        func(utils.RetryableServiceClient, ports.ListOpts) (pagination.Page, error)
	listPortsMutex       sync.RWMutex
	listPortsArgsForCall []struct {
		arg1 utils.RetryableServiceClient
		arg2 ports.ListOpts
	}
	listPortsReturns struct {
		result1 pagination.Page
		result2 error
	}
	listPortsReturnsOnCall map[int]struct {
		result1 pagination.Page
		result2 error
	}
	ListSecurityGroupsStub        func(utils.RetryableServiceClient, groups.ListOpts) (pagination.Page, error)
	listSecurityGroupsMutex       sync.RWMutex
	listSecurityGroupsArgsForCall []struct {
		arg1 utils.RetryableServiceClient
		arg2 groups.ListOpts
	}
	listSecurityGroupsReturns struct {
		result1 pagination.Page
		result2 error
	}
	listSecurityGroupsReturnsOnCall map[int]struct {
		result1 pagination.Page
		result2 error
	}
	ListSubnetsStub        func(utils.RetryableServiceClient, subnets.ListOpts) (pagination.Page, error)
	listSubnetsMutex       sync.RWMutex
	listSubnetsArgsForCall []struct {
		arg1 utils.RetryableServiceClient
		arg2 subnets.ListOpts
	}
	listSubnetsReturns struct {
		result1 pagination.Page
		result2 error
	}
	listSubnetsReturnsOnCall map[int]struct {
		result1 pagination.Page
		result2 error
	}
	UpdateFloatingIPStub        func(utils.ServiceClient, string, floatingips.UpdateOpts) (*floatingips.FloatingIP, error)
	updateFloatingIPMutex       sync.RWMutex
	updateFloatingIPArgsForCall []struct {
		arg1 utils.ServiceClient
		arg2 string
		arg3 floatingips.UpdateOpts
	}
	updateFloatingIPReturns struct {
		result1 *floatingips.FloatingIP
		result2 error
	}
	updateFloatingIPReturnsOnCall map[int]struct {
		result1 *floatingips.FloatingIP
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeNetworkingFacade) CreatePort(arg1 utils.ServiceClient, arg2 ports.CreateOpts) (*ports.Port, error) {
	fake.createPortMutex.Lock()
	ret, specificReturn := fake.createPortReturnsOnCall[len(fake.createPortArgsForCall)]
	fake.createPortArgsForCall = append(fake.createPortArgsForCall, struct {
		arg1 utils.ServiceClient
		arg2 ports.CreateOpts
	}{arg1, arg2})
	stub := fake.CreatePortStub
	fakeReturns := fake.createPortReturns
	fake.recordInvocation("CreatePort", []interface{}{arg1, arg2})
	fake.createPortMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNetworkingFacade) CreatePortCallCount() int {
	fake.createPortMutex.RLock()
	defer fake.createPortMutex.RUnlock()
	return len(fake.createPortArgsForCall)
}

func (fake *FakeNetworkingFacade) CreatePortCalls(stub func(utils.ServiceClient, ports.CreateOpts) (*ports.Port, error)) {
	fake.createPortMutex.Lock()
	defer fake.createPortMutex.Unlock()
	fake.CreatePortStub = stub
}

func (fake *FakeNetworkingFacade) CreatePortArgsForCall(i int) (utils.ServiceClient, ports.CreateOpts) {
	fake.createPortMutex.RLock()
	defer fake.createPortMutex.RUnlock()
	argsForCall := fake.createPortArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNetworkingFacade) CreatePortReturns(result1 *ports.Port, result2 error) {
	fake.createPortMutex.Lock()
	defer fake.createPortMutex.Unlock()
	fake.CreatePortStub = nil
	fake.createPortReturns = struct {
		result1 *ports.Port
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkingFacade) CreatePortReturnsOnCall(i int, result1 *ports.Port, result2 error) {
	fake.createPortMutex.Lock()
	defer fake.createPortMutex.Unlock()
	fake.CreatePortStub = nil
	if fake.createPortReturnsOnCall == nil {
		fake.createPortReturnsOnCall = make(map[int]struct {
			result1 *ports.Port
			result2 error
		})
	}
	fake.createPortReturnsOnCall[i] = struct {
		result1 *ports.Port
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkingFacade) DeletePort(arg1 utils.RetryableServiceClient, arg2 string) error {
	fake.deletePortMutex.Lock()
	ret, specificReturn := fake.deletePortReturnsOnCall[len(fake.deletePortArgsForCall)]
	fake.deletePortArgsForCall = append(fake.deletePortArgsForCall, struct {
		arg1 utils.RetryableServiceClient
		arg2 string
	}{arg1, arg2})
	stub := fake.DeletePortStub
	fakeReturns := fake.deletePortReturns
	fake.recordInvocation("DeletePort", []interface{}{arg1, arg2})
	fake.deletePortMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeNetworkingFacade) DeletePortCallCount() int {
	fake.deletePortMutex.RLock()
	defer fake.deletePortMutex.RUnlock()
	return len(fake.deletePortArgsForCall)
}

func (fake *FakeNetworkingFacade) DeletePortCalls(stub func(utils.RetryableServiceClient, string) error) {
	fake.deletePortMutex.Lock()
	defer fake.deletePortMutex.Unlock()
	fake.DeletePortStub = stub
}

func (fake *FakeNetworkingFacade) DeletePortArgsForCall(i int) (utils.RetryableServiceClient, string) {
	fake.deletePortMutex.RLock()
	defer fake.deletePortMutex.RUnlock()
	argsForCall := fake.deletePortArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNetworkingFacade) DeletePortReturns(result1 error) {
	fake.deletePortMutex.Lock()
	defer fake.deletePortMutex.Unlock()
	fake.DeletePortStub = nil
	fake.deletePortReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkingFacade) DeletePortReturnsOnCall(i int, result1 error) {
	fake.deletePortMutex.Lock()
	defer fake.deletePortMutex.Unlock()
	fake.DeletePortStub = nil
	if fake.deletePortReturnsOnCall == nil {
		fake.deletePortReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deletePortReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkingFacade) ExtractFloatingIPs(arg1 pagination.Page) ([]floatingips.FloatingIP, error) {
	fake.extractFloatingIPsMutex.Lock()
	ret, specificReturn := fake.extractFloatingIPsReturnsOnCall[len(fake.extractFloatingIPsArgsForCall)]
	fake.extractFloatingIPsArgsForCall = append(fake.extractFloatingIPsArgsForCall, struct {
		arg1 pagination.Page
	}{arg1})
	stub := fake.ExtractFloatingIPsStub
	fakeReturns := fake.extractFloatingIPsReturns
	fake.recordInvocation("ExtractFloatingIPs", []interface{}{arg1})
	fake.extractFloatingIPsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNetworkingFacade) ExtractFloatingIPsCallCount() int {
	fake.extractFloatingIPsMutex.RLock()
	defer fake.extractFloatingIPsMutex.RUnlock()
	return len(fake.extractFloatingIPsArgsForCall)
}

func (fake *FakeNetworkingFacade) ExtractFloatingIPsCalls(stub func(pagination.Page) ([]floatingips.FloatingIP, error)) {
	fake.extractFloatingIPsMutex.Lock()
	defer fake.extractFloatingIPsMutex.Unlock()
	fake.ExtractFloatingIPsStub = stub
}

func (fake *FakeNetworkingFacade) ExtractFloatingIPsArgsForCall(i int) pagination.Page {
	fake.extractFloatingIPsMutex.RLock()
	defer fake.extractFloatingIPsMutex.RUnlock()
	argsForCall := fake.extractFloatingIPsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeNetworkingFacade) ExtractFloatingIPsReturns(result1 []floatingips.FloatingIP, result2 error) {
	fake.extractFloatingIPsMutex.Lock()
	defer fake.extractFloatingIPsMutex.Unlock()
	fake.ExtractFloatingIPsStub = nil
	fake.extractFloatingIPsReturns = struct {
		result1 []floatingips.FloatingIP
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkingFacade) ExtractFloatingIPsReturnsOnCall(i int, result1 []floatingips.FloatingIP, result2 error) {
	fake.extractFloatingIPsMutex.Lock()
	defer fake.extractFloatingIPsMutex.Unlock()
	fake.ExtractFloatingIPsStub = nil
	if fake.extractFloatingIPsReturnsOnCall == nil {
		fake.extractFloatingIPsReturnsOnCall = make(map[int]struct {
			result1 []floatingips.FloatingIP
			result2 error
		})
	}
	fake.extractFloatingIPsReturnsOnCall[i] = struct {
		result1 []floatingips.FloatingIP
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkingFacade) ExtractPorts(arg1 pagination.Page) ([]ports.Port, error) {
	fake.extractPortsMutex.Lock()
	ret, specificReturn := fake.extractPortsReturnsOnCall[len(fake.extractPortsArgsForCall)]
	fake.extractPortsArgsForCall = append(fake.extractPortsArgsForCall, struct {
		arg1 pagination.Page
	}{arg1})
	stub := fake.ExtractPortsStub
	fakeReturns := fake.extractPortsReturns
	fake.recordInvocation("ExtractPorts", []interface{}{arg1})
	fake.extractPortsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNetworkingFacade) ExtractPortsCallCount() int {
	fake.extractPortsMutex.RLock()
	defer fake.extractPortsMutex.RUnlock()
	return len(fake.extractPortsArgsForCall)
}

func (fake *FakeNetworkingFacade) ExtractPortsCalls(stub func(pagination.Page) ([]ports.Port, error)) {
	fake.extractPortsMutex.Lock()
	defer fake.extractPortsMutex.Unlock()
	fake.ExtractPortsStub = stub
}

func (fake *FakeNetworkingFacade) ExtractPortsArgsForCall(i int) pagination.Page {
	fake.extractPortsMutex.RLock()
	defer fake.extractPortsMutex.RUnlock()
	argsForCall := fake.extractPortsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeNetworkingFacade) ExtractPortsReturns(result1 []ports.Port, result2 error) {
	fake.extractPortsMutex.Lock()
	defer fake.extractPortsMutex.Unlock()
	fake.ExtractPortsStub = nil
	fake.extractPortsReturns = struct {
		result1 []ports.Port
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkingFacade) ExtractPortsReturnsOnCall(i int, result1 []ports.Port, result2 error) {
	fake.extractPortsMutex.Lock()
	defer fake.extractPortsMutex.Unlock()
	fake.ExtractPortsStub = nil
	if fake.extractPortsReturnsOnCall == nil {
		fake.extractPortsReturnsOnCall = make(map[int]struct {
			result1 []ports.Port
			result2 error
		})
	}
	fake.extractPortsReturnsOnCall[i] = struct {
		result1 []ports.Port
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkingFacade) ExtractSecurityGroups(arg1 pagination.Page) ([]groups.SecGroup, error) {
	fake.extractSecurityGroupsMutex.Lock()
	ret, specificReturn := fake.extractSecurityGroupsReturnsOnCall[len(fake.extractSecurityGroupsArgsForCall)]
	fake.extractSecurityGroupsArgsForCall = append(fake.extractSecurityGroupsArgsForCall, struct {
		arg1 pagination.Page
	}{arg1})
	stub := fake.ExtractSecurityGroupsStub
	fakeReturns := fake.extractSecurityGroupsReturns
	fake.recordInvocation("ExtractSecurityGroups", []interface{}{arg1})
	fake.extractSecurityGroupsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNetworkingFacade) ExtractSecurityGroupsCallCount() int {
	fake.extractSecurityGroupsMutex.RLock()
	defer fake.extractSecurityGroupsMutex.RUnlock()
	return len(fake.extractSecurityGroupsArgsForCall)
}

func (fake *FakeNetworkingFacade) ExtractSecurityGroupsCalls(stub func(pagination.Page) ([]groups.SecGroup, error)) {
	fake.extractSecurityGroupsMutex.Lock()
	defer fake.extractSecurityGroupsMutex.Unlock()
	fake.ExtractSecurityGroupsStub = stub
}

func (fake *FakeNetworkingFacade) ExtractSecurityGroupsArgsForCall(i int) pagination.Page {
	fake.extractSecurityGroupsMutex.RLock()
	defer fake.extractSecurityGroupsMutex.RUnlock()
	argsForCall := fake.extractSecurityGroupsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeNetworkingFacade) ExtractSecurityGroupsReturns(result1 []groups.SecGroup, result2 error) {
	fake.extractSecurityGroupsMutex.Lock()
	defer fake.extractSecurityGroupsMutex.Unlock()
	fake.ExtractSecurityGroupsStub = nil
	fake.extractSecurityGroupsReturns = struct {
		result1 []groups.SecGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkingFacade) ExtractSecurityGroupsReturnsOnCall(i int, result1 []groups.SecGroup, result2 error) {
	fake.extractSecurityGroupsMutex.Lock()
	defer fake.extractSecurityGroupsMutex.Unlock()
	fake.ExtractSecurityGroupsStub = nil
	if fake.extractSecurityGroupsReturnsOnCall == nil {
		fake.extractSecurityGroupsReturnsOnCall = make(map[int]struct {
			result1 []groups.SecGroup
			result2 error
		})
	}
	fake.extractSecurityGroupsReturnsOnCall[i] = struct {
		result1 []groups.SecGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkingFacade) ExtractSubnets(arg1 pagination.Page) ([]subnets.Subnet, error) {
	fake.extractSubnetsMutex.Lock()
	ret, specificReturn := fake.extractSubnetsReturnsOnCall[len(fake.extractSubnetsArgsForCall)]
	fake.extractSubnetsArgsForCall = append(fake.extractSubnetsArgsForCall, struct {
		arg1 pagination.Page
	}{arg1})
	stub := fake.ExtractSubnetsStub
	fakeReturns := fake.extractSubnetsReturns
	fake.recordInvocation("ExtractSubnets", []interface{}{arg1})
	fake.extractSubnetsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNetworkingFacade) ExtractSubnetsCallCount() int {
	fake.extractSubnetsMutex.RLock()
	defer fake.extractSubnetsMutex.RUnlock()
	return len(fake.extractSubnetsArgsForCall)
}

func (fake *FakeNetworkingFacade) ExtractSubnetsCalls(stub func(pagination.Page) ([]subnets.Subnet, error)) {
	fake.extractSubnetsMutex.Lock()
	defer fake.extractSubnetsMutex.Unlock()
	fake.ExtractSubnetsStub = stub
}

func (fake *FakeNetworkingFacade) ExtractSubnetsArgsForCall(i int) pagination.Page {
	fake.extractSubnetsMutex.RLock()
	defer fake.extractSubnetsMutex.RUnlock()
	argsForCall := fake.extractSubnetsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeNetworkingFacade) ExtractSubnetsReturns(result1 []subnets.Subnet, result2 error) {
	fake.extractSubnetsMutex.Lock()
	defer fake.extractSubnetsMutex.Unlock()
	fake.ExtractSubnetsStub = nil
	fake.extractSubnetsReturns = struct {
		result1 []subnets.Subnet
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkingFacade) ExtractSubnetsReturnsOnCall(i int, result1 []subnets.Subnet, result2 error) {
	fake.extractSubnetsMutex.Lock()
	defer fake.extractSubnetsMutex.Unlock()
	fake.ExtractSubnetsStub = nil
	if fake.extractSubnetsReturnsOnCall == nil {
		fake.extractSubnetsReturnsOnCall = make(map[int]struct {
			result1 []subnets.Subnet
			result2 error
		})
	}
	fake.extractSubnetsReturnsOnCall[i] = struct {
		result1 []subnets.Subnet
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkingFacade) GetSecurityGroups(arg1 utils.RetryableServiceClient, arg2 string) (*groups.SecGroup, error) {
	fake.getSecurityGroupsMutex.Lock()
	ret, specificReturn := fake.getSecurityGroupsReturnsOnCall[len(fake.getSecurityGroupsArgsForCall)]
	fake.getSecurityGroupsArgsForCall = append(fake.getSecurityGroupsArgsForCall, struct {
		arg1 utils.RetryableServiceClient
		arg2 string
	}{arg1, arg2})
	stub := fake.GetSecurityGroupsStub
	fakeReturns := fake.getSecurityGroupsReturns
	fake.recordInvocation("GetSecurityGroups", []interface{}{arg1, arg2})
	fake.getSecurityGroupsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNetworkingFacade) GetSecurityGroupsCallCount() int {
	fake.getSecurityGroupsMutex.RLock()
	defer fake.getSecurityGroupsMutex.RUnlock()
	return len(fake.getSecurityGroupsArgsForCall)
}

func (fake *FakeNetworkingFacade) GetSecurityGroupsCalls(stub func(utils.RetryableServiceClient, string) (*groups.SecGroup, error)) {
	fake.getSecurityGroupsMutex.Lock()
	defer fake.getSecurityGroupsMutex.Unlock()
	fake.GetSecurityGroupsStub = stub
}

func (fake *FakeNetworkingFacade) GetSecurityGroupsArgsForCall(i int) (utils.RetryableServiceClient, string) {
	fake.getSecurityGroupsMutex.RLock()
	defer fake.getSecurityGroupsMutex.RUnlock()
	argsForCall := fake.getSecurityGroupsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNetworkingFacade) GetSecurityGroupsReturns(result1 *groups.SecGroup, result2 error) {
	fake.getSecurityGroupsMutex.Lock()
	defer fake.getSecurityGroupsMutex.Unlock()
	fake.GetSecurityGroupsStub = nil
	fake.getSecurityGroupsReturns = struct {
		result1 *groups.SecGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkingFacade) GetSecurityGroupsReturnsOnCall(i int, result1 *groups.SecGroup, result2 error) {
	fake.getSecurityGroupsMutex.Lock()
	defer fake.getSecurityGroupsMutex.Unlock()
	fake.GetSecurityGroupsStub = nil
	if fake.getSecurityGroupsReturnsOnCall == nil {
		fake.getSecurityGroupsReturnsOnCall = make(map[int]struct {
			result1 *groups.SecGroup
			result2 error
		})
	}
	fake.getSecurityGroupsReturnsOnCall[i] = struct {
		result1 *groups.SecGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkingFacade) ListFloatingIps(arg1 utils.RetryableServiceClient, arg2 floatingips.ListOpts) (pagination.Page, error) {
	fake.listFloatingIpsMutex.Lock()
	ret, specificReturn := fake.listFloatingIpsReturnsOnCall[len(fake.listFloatingIpsArgsForCall)]
	fake.listFloatingIpsArgsForCall = append(fake.listFloatingIpsArgsForCall, struct {
		arg1 utils.RetryableServiceClient
		arg2 floatingips.ListOpts
	}{arg1, arg2})
	stub := fake.ListFloatingIpsStub
	fakeReturns := fake.listFloatingIpsReturns
	fake.recordInvocation("ListFloatingIps", []interface{}{arg1, arg2})
	fake.listFloatingIpsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNetworkingFacade) ListFloatingIpsCallCount() int {
	fake.listFloatingIpsMutex.RLock()
	defer fake.listFloatingIpsMutex.RUnlock()
	return len(fake.listFloatingIpsArgsForCall)
}

func (fake *FakeNetworkingFacade) ListFloatingIpsCalls(stub func(utils.RetryableServiceClient, floatingips.ListOpts) (pagination.Page, error)) {
	fake.listFloatingIpsMutex.Lock()
	defer fake.listFloatingIpsMutex.Unlock()
	fake.ListFloatingIpsStub = stub
}

func (fake *FakeNetworkingFacade) ListFloatingIpsArgsForCall(i int) (utils.RetryableServiceClient, floatingips.ListOpts) {
	fake.listFloatingIpsMutex.RLock()
	defer fake.listFloatingIpsMutex.RUnlock()
	argsForCall := fake.listFloatingIpsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNetworkingFacade) ListFloatingIpsReturns(result1 pagination.Page, result2 error) {
	fake.listFloatingIpsMutex.Lock()
	defer fake.listFloatingIpsMutex.Unlock()
	fake.ListFloatingIpsStub = nil
	fake.listFloatingIpsReturns = struct {
		result1 pagination.Page
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkingFacade) ListFloatingIpsReturnsOnCall(i int, result1 pagination.Page, result2 error) {
	fake.listFloatingIpsMutex.Lock()
	defer fake.listFloatingIpsMutex.Unlock()
	fake.ListFloatingIpsStub = nil
	if fake.listFloatingIpsReturnsOnCall == nil {
		fake.listFloatingIpsReturnsOnCall = make(map[int]struct {
			result1 pagination.Page
			result2 error
		})
	}
	fake.listFloatingIpsReturnsOnCall[i] = struct {
		result1 pagination.Page
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkingFacade) ListPorts(arg1 utils.RetryableServiceClient, arg2 ports.ListOpts) (pagination.Page, error) {
	fake.listPortsMutex.Lock()
	ret, specificReturn := fake.listPortsReturnsOnCall[len(fake.listPortsArgsForCall)]
	fake.listPortsArgsForCall = append(fake.listPortsArgsForCall, struct {
		arg1 utils.RetryableServiceClient
		arg2 ports.ListOpts
	}{arg1, arg2})
	stub := fake.ListPortsStub
	fakeReturns := fake.listPortsReturns
	fake.recordInvocation("ListPorts", []interface{}{arg1, arg2})
	fake.listPortsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNetworkingFacade) ListPortsCallCount() int {
	fake.listPortsMutex.RLock()
	defer fake.listPortsMutex.RUnlock()
	return len(fake.listPortsArgsForCall)
}

func (fake *FakeNetworkingFacade) ListPortsCalls(stub func(utils.RetryableServiceClient, ports.ListOpts) (pagination.Page, error)) {
	fake.listPortsMutex.Lock()
	defer fake.listPortsMutex.Unlock()
	fake.ListPortsStub = stub
}

func (fake *FakeNetworkingFacade) ListPortsArgsForCall(i int) (utils.RetryableServiceClient, ports.ListOpts) {
	fake.listPortsMutex.RLock()
	defer fake.listPortsMutex.RUnlock()
	argsForCall := fake.listPortsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNetworkingFacade) ListPortsReturns(result1 pagination.Page, result2 error) {
	fake.listPortsMutex.Lock()
	defer fake.listPortsMutex.Unlock()
	fake.ListPortsStub = nil
	fake.listPortsReturns = struct {
		result1 pagination.Page
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkingFacade) ListPortsReturnsOnCall(i int, result1 pagination.Page, result2 error) {
	fake.listPortsMutex.Lock()
	defer fake.listPortsMutex.Unlock()
	fake.ListPortsStub = nil
	if fake.listPortsReturnsOnCall == nil {
		fake.listPortsReturnsOnCall = make(map[int]struct {
			result1 pagination.Page
			result2 error
		})
	}
	fake.listPortsReturnsOnCall[i] = struct {
		result1 pagination.Page
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkingFacade) ListSecurityGroups(arg1 utils.RetryableServiceClient, arg2 groups.ListOpts) (pagination.Page, error) {
	fake.listSecurityGroupsMutex.Lock()
	ret, specificReturn := fake.listSecurityGroupsReturnsOnCall[len(fake.listSecurityGroupsArgsForCall)]
	fake.listSecurityGroupsArgsForCall = append(fake.listSecurityGroupsArgsForCall, struct {
		arg1 utils.RetryableServiceClient
		arg2 groups.ListOpts
	}{arg1, arg2})
	stub := fake.ListSecurityGroupsStub
	fakeReturns := fake.listSecurityGroupsReturns
	fake.recordInvocation("ListSecurityGroups", []interface{}{arg1, arg2})
	fake.listSecurityGroupsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNetworkingFacade) ListSecurityGroupsCallCount() int {
	fake.listSecurityGroupsMutex.RLock()
	defer fake.listSecurityGroupsMutex.RUnlock()
	return len(fake.listSecurityGroupsArgsForCall)
}

func (fake *FakeNetworkingFacade) ListSecurityGroupsCalls(stub func(utils.RetryableServiceClient, groups.ListOpts) (pagination.Page, error)) {
	fake.listSecurityGroupsMutex.Lock()
	defer fake.listSecurityGroupsMutex.Unlock()
	fake.ListSecurityGroupsStub = stub
}

func (fake *FakeNetworkingFacade) ListSecurityGroupsArgsForCall(i int) (utils.RetryableServiceClient, groups.ListOpts) {
	fake.listSecurityGroupsMutex.RLock()
	defer fake.listSecurityGroupsMutex.RUnlock()
	argsForCall := fake.listSecurityGroupsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNetworkingFacade) ListSecurityGroupsReturns(result1 pagination.Page, result2 error) {
	fake.listSecurityGroupsMutex.Lock()
	defer fake.listSecurityGroupsMutex.Unlock()
	fake.ListSecurityGroupsStub = nil
	fake.listSecurityGroupsReturns = struct {
		result1 pagination.Page
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkingFacade) ListSecurityGroupsReturnsOnCall(i int, result1 pagination.Page, result2 error) {
	fake.listSecurityGroupsMutex.Lock()
	defer fake.listSecurityGroupsMutex.Unlock()
	fake.ListSecurityGroupsStub = nil
	if fake.listSecurityGroupsReturnsOnCall == nil {
		fake.listSecurityGroupsReturnsOnCall = make(map[int]struct {
			result1 pagination.Page
			result2 error
		})
	}
	fake.listSecurityGroupsReturnsOnCall[i] = struct {
		result1 pagination.Page
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkingFacade) ListSubnets(arg1 utils.RetryableServiceClient, arg2 subnets.ListOpts) (pagination.Page, error) {
	fake.listSubnetsMutex.Lock()
	ret, specificReturn := fake.listSubnetsReturnsOnCall[len(fake.listSubnetsArgsForCall)]
	fake.listSubnetsArgsForCall = append(fake.listSubnetsArgsForCall, struct {
		arg1 utils.RetryableServiceClient
		arg2 subnets.ListOpts
	}{arg1, arg2})
	stub := fake.ListSubnetsStub
	fakeReturns := fake.listSubnetsReturns
	fake.recordInvocation("ListSubnets", []interface{}{arg1, arg2})
	fake.listSubnetsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNetworkingFacade) ListSubnetsCallCount() int {
	fake.listSubnetsMutex.RLock()
	defer fake.listSubnetsMutex.RUnlock()
	return len(fake.listSubnetsArgsForCall)
}

func (fake *FakeNetworkingFacade) ListSubnetsCalls(stub func(utils.RetryableServiceClient, subnets.ListOpts) (pagination.Page, error)) {
	fake.listSubnetsMutex.Lock()
	defer fake.listSubnetsMutex.Unlock()
	fake.ListSubnetsStub = stub
}

func (fake *FakeNetworkingFacade) ListSubnetsArgsForCall(i int) (utils.RetryableServiceClient, subnets.ListOpts) {
	fake.listSubnetsMutex.RLock()
	defer fake.listSubnetsMutex.RUnlock()
	argsForCall := fake.listSubnetsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNetworkingFacade) ListSubnetsReturns(result1 pagination.Page, result2 error) {
	fake.listSubnetsMutex.Lock()
	defer fake.listSubnetsMutex.Unlock()
	fake.ListSubnetsStub = nil
	fake.listSubnetsReturns = struct {
		result1 pagination.Page
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkingFacade) ListSubnetsReturnsOnCall(i int, result1 pagination.Page, result2 error) {
	fake.listSubnetsMutex.Lock()
	defer fake.listSubnetsMutex.Unlock()
	fake.ListSubnetsStub = nil
	if fake.listSubnetsReturnsOnCall == nil {
		fake.listSubnetsReturnsOnCall = make(map[int]struct {
			result1 pagination.Page
			result2 error
		})
	}
	fake.listSubnetsReturnsOnCall[i] = struct {
		result1 pagination.Page
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkingFacade) UpdateFloatingIP(arg1 utils.ServiceClient, arg2 string, arg3 floatingips.UpdateOpts) (*floatingips.FloatingIP, error) {
	fake.updateFloatingIPMutex.Lock()
	ret, specificReturn := fake.updateFloatingIPReturnsOnCall[len(fake.updateFloatingIPArgsForCall)]
	fake.updateFloatingIPArgsForCall = append(fake.updateFloatingIPArgsForCall, struct {
		arg1 utils.ServiceClient
		arg2 string
		arg3 floatingips.UpdateOpts
	}{arg1, arg2, arg3})
	stub := fake.UpdateFloatingIPStub
	fakeReturns := fake.updateFloatingIPReturns
	fake.recordInvocation("UpdateFloatingIP", []interface{}{arg1, arg2, arg3})
	fake.updateFloatingIPMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNetworkingFacade) UpdateFloatingIPCallCount() int {
	fake.updateFloatingIPMutex.RLock()
	defer fake.updateFloatingIPMutex.RUnlock()
	return len(fake.updateFloatingIPArgsForCall)
}

func (fake *FakeNetworkingFacade) UpdateFloatingIPCalls(stub func(utils.ServiceClient, string, floatingips.UpdateOpts) (*floatingips.FloatingIP, error)) {
	fake.updateFloatingIPMutex.Lock()
	defer fake.updateFloatingIPMutex.Unlock()
	fake.UpdateFloatingIPStub = stub
}

func (fake *FakeNetworkingFacade) UpdateFloatingIPArgsForCall(i int) (utils.ServiceClient, string, floatingips.UpdateOpts) {
	fake.updateFloatingIPMutex.RLock()
	defer fake.updateFloatingIPMutex.RUnlock()
	argsForCall := fake.updateFloatingIPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeNetworkingFacade) UpdateFloatingIPReturns(result1 *floatingips.FloatingIP, result2 error) {
	fake.updateFloatingIPMutex.Lock()
	defer fake.updateFloatingIPMutex.Unlock()
	fake.UpdateFloatingIPStub = nil
	fake.updateFloatingIPReturns = struct {
		result1 *floatingips.FloatingIP
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkingFacade) UpdateFloatingIPReturnsOnCall(i int, result1 *floatingips.FloatingIP, result2 error) {
	fake.updateFloatingIPMutex.Lock()
	defer fake.updateFloatingIPMutex.Unlock()
	fake.UpdateFloatingIPStub = nil
	if fake.updateFloatingIPReturnsOnCall == nil {
		fake.updateFloatingIPReturnsOnCall = make(map[int]struct {
			result1 *floatingips.FloatingIP
			result2 error
		})
	}
	fake.updateFloatingIPReturnsOnCall[i] = struct {
		result1 *floatingips.FloatingIP
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkingFacade) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createPortMutex.RLock()
	defer fake.createPortMutex.RUnlock()
	fake.deletePortMutex.RLock()
	defer fake.deletePortMutex.RUnlock()
	fake.extractFloatingIPsMutex.RLock()
	defer fake.extractFloatingIPsMutex.RUnlock()
	fake.extractPortsMutex.RLock()
	defer fake.extractPortsMutex.RUnlock()
	fake.extractSecurityGroupsMutex.RLock()
	defer fake.extractSecurityGroupsMutex.RUnlock()
	fake.extractSubnetsMutex.RLock()
	defer fake.extractSubnetsMutex.RUnlock()
	fake.getSecurityGroupsMutex.RLock()
	defer fake.getSecurityGroupsMutex.RUnlock()
	fake.listFloatingIpsMutex.RLock()
	defer fake.listFloatingIpsMutex.RUnlock()
	fake.listPortsMutex.RLock()
	defer fake.listPortsMutex.RUnlock()
	fake.listSecurityGroupsMutex.RLock()
	defer fake.listSecurityGroupsMutex.RUnlock()
	fake.listSubnetsMutex.RLock()
	defer fake.listSubnetsMutex.RUnlock()
	fake.updateFloatingIPMutex.RLock()
	defer fake.updateFloatingIPMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeNetworkingFacade) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ network.NetworkingFacade = new(FakeNetworkingFacade)
